"""EnableBanking file-based transaction source.

Data format
===========

This source imports transactions from EnableBanking API exports (JSON files 
generated by finance-dl). EnableBanking supports multiple banks through
Open Banking APIs.

Directory structure:
    enablebanking/
      mbank/
        accounts.json
        session.json
        transactions_PL47114020040000370280642872_PLN.json
        ...
      revolut/
        accounts.json
        transactions_PL29291000060000000002747867_PLN.json
        ...

Specifying the source to beancount_import
=========================================

Within your Python script for invoking beancount_import, use an expression like:

    dict(
        module='beancount_import.source.enablebanking',
        data_directory='/path/to/enablebanking',  # Parent dir with bank subdirs
        account_map={
            'PL47114020040000370280642872_PLN': 'Assets:mBank:Daventi',
            'PL29291000060000000002747867_PLN': 'Assets:Revolut:PLN',
            # Format: IBAN_CURRENCY -> Beancount account
        },
        default_account='Assets:Bank:Unknown',  # Fallback for unknown accounts
    )

Imported transaction format
===========================

Transactions are generated in the following form:

    2024-01-02 * "STARBUCKS" "Kawa"
      Assets:Revolut:PLN     -15.00 PLN
        enablebanking_ref: "694f6cf3-562b-a9cb-a010-67b3b2852d9d"
        enablebanking_bank: "Revolut"
        enablebanking_type: "CARD_PAYMENT"
      Expenses:FIXME          15.00 PLN

The `enablebanking_ref` metadata field (entry_reference from EnableBanking) 
is used to match transactions and avoid duplicates.
"""

import collections
import datetime
import hashlib
import json
import os
from dataclasses import dataclass
from decimal import Decimal, InvalidOperation
from typing import Dict, List, Optional, Tuple

from beancount.core.data import Balance, Posting, Transaction, EMPTY_SET
from beancount.core.flags import FLAG_OKAY
from beancount.core.number import D, ZERO
from beancount.core.amount import Amount

from . import ImportResult, Source, SourceResults, InvalidSourceReference
from ..matching import FIXME_ACCOUNT
from ..journal_editor import JournalEditor
from .enablebanking_rules import get_parsed_transaction, KNOWN_TRANSACTION_TYPES


# Metadata keys (standardized across all bank sources)
SOURCE_REF_KEY = 'source_ref'  # Unique transaction reference
SOURCE_BANK_KEY = 'source_bank'  # Bank/ASPSP name
TRANSACTION_TYPE_KEY = 'transaction_type'  # Transaction code (CARD_PAYMENT, TRANSFER, etc.)
COUNTERPARTY_KEY = 'counterparty'  # Counterparty name
COUNTERPARTY_ADDRESS_KEY = 'counterparty_address'  # Counterparty address (extracted from name)
COUNTERPARTY_IBAN_KEY = 'counterparty_iban'  # Counterparty IBAN (with country prefix)
COUNTERPARTY_BBAN_KEY = 'counterparty_bban'  # Counterparty BBAN (without country prefix)
ACCOUNT_IBAN_KEY = 'account_iban'  # Own account IBAN
TITLE_KEY = 'title'  # Transaction title/remittance
TRANSACTION_DATE_KEY = 'transaction_date'  # Value/transaction date (when money moved)
BOOKING_DATE_KEY = 'booking_date'  # Booking date (when bank recorded it)


def _split_counterparty_address(name: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    """Split counterparty name from address.
    
    Handles two patterns:
    1. Comma separator (mBank): "AUTOPAY SA, UL. POWSTAŃCÓW WARSZAWY 6, 81-718 SOPOT"
       -> ("AUTOPAY SA", "UL. POWSTAŃCÓW WARSZAWY 6, 81-718 SOPOT")
    2. Multiple spaces (Pekao): "KAUFLAND               MYSLOWICE"
       -> ("KAUFLAND", "MYSLOWICE")
    
    Returns: (name, address) tuple. Address is None if no separator found.
    """
    import re
    if not name:
        return None, None
    
    # First try comma separator
    if ',' in name:
        parts = name.split(',', 1)
        return parts[0].strip(), parts[1].strip()
    
    # Try multiple spaces (3 or more) as separator
    parts = re.split(r'\s{3,}', name, maxsplit=1)
    if len(parts) == 2:
        return parts[0].strip(), parts[1].strip()
    
    return name, None


@dataclass
class EnableBankingAccount:
    """Account information from EnableBanking."""
    iban: str
    currency: str
    name: str
    product: Optional[str]
    bank: str  # aspsp_id from accounts.json
    account_id: str  # IBAN_CURRENCY format for file matching


@dataclass
class EnableBankingTransaction:
    """Transaction from EnableBanking."""
    entry_reference: str
    amount: Decimal
    currency: str
    credit_debit_indicator: str  # CRDT or DBIT
    booking_date: datetime.date
    transaction_date: Optional[datetime.date]
    value_date: Optional[datetime.date]
    status: str  # BOOK, PDNG, etc.
    # Counterparty info
    creditor_name: Optional[str]
    creditor_iban: Optional[str]
    creditor_address: Optional[str]  # From postal_address.address_line
    debtor_name: Optional[str]
    debtor_iban: Optional[str]
    debtor_address: Optional[str]  # From postal_address.address_line
    # Description
    remittance_information: List[str]
    # Transaction code
    bank_transaction_code: Optional[str]
    # Balance
    balance_after: Optional[Decimal]
    # Source info
    account_id: str
    bank: str


def _parse_decimal(value: Optional[str]) -> Optional[Decimal]:
    """Parse decimal from string, returning None on error."""
    if not value:
        return None
    try:
        return D(str(value))
    except (InvalidOperation, ValueError):
        return None


def _parse_date(value: Optional[str]) -> Optional[datetime.date]:
    """Parse ISO date string."""
    if not value:
        return None
    try:
        return datetime.date.fromisoformat(value[:10])
    except (ValueError, TypeError):
        return None


def _extract_account_iban(account_id_obj: Optional[dict]) -> Optional[str]:
    """Extract IBAN from account_id object."""
    if not account_id_obj:
        return None
    # Try iban field first
    iban = account_id_obj.get('iban')
    if iban:
        return iban
    # Try other.identification for BBAN
    other = account_id_obj.get('other')
    if other and other.get('identification'):
        return other['identification']
    return None


def _extract_address(postal_address: Optional[dict]) -> Optional[str]:
    """Extract address from postal_address object.
    
    Joins address_line entries into a single string, cleaning up extra whitespace.
    Example input: {"address_line": ["UL. KS. JANA NYGI 1A/15", "41-400    MYSŁOWICE           PL"]}
    Example output: "UL. KS. JANA NYGI 1A/15, 41-400 MYSŁOWICE PL"
    """
    if not postal_address:
        return None
    address_lines = postal_address.get('address_line') or []
    if not address_lines:
        return None
    # Clean up each line and join with comma
    cleaned = []
    for line in address_lines:
        if line:
            # Normalize whitespace
            cleaned_line = ' '.join(line.split())
            if cleaned_line:
                cleaned.append(cleaned_line)
    return ', '.join(cleaned) if cleaned else None


def _parse_transaction(txn_data: dict, account_id: str, bank: str) -> Optional[EnableBankingTransaction]:
    """Parse a single transaction from JSON data."""
    entry_ref = txn_data.get('entry_reference')
    if not entry_ref:
        return None
    
    # Parse amount
    amount_obj = txn_data.get('transaction_amount', {})
    amount_str = amount_obj.get('amount')
    currency = amount_obj.get('currency', 'PLN')
    
    amount = _parse_decimal(amount_str)
    if amount is None:
        return None
    
    # Validate that amount is an actual Decimal instance, not the class
    if not isinstance(amount, Decimal):
        print(f"[enablebanking] ERROR: amount is not Decimal instance: {type(amount)} for {entry_ref}")
        return None
    
    # Credit/debit indicator
    indicator = txn_data.get('credit_debit_indicator', 'DBIT')
    
    # Apply sign based on indicator
    if indicator == 'DBIT':
        amount = -abs(amount)
    else:
        amount = abs(amount)
    
    # Parse dates
    booking_date = _parse_date(txn_data.get('booking_date'))
    if not booking_date:
        return None
    
    transaction_date = _parse_date(txn_data.get('transaction_date'))
    value_date = _parse_date(txn_data.get('value_date'))
    
    # Creditor info
    creditor = txn_data.get('creditor') or {}
    creditor_name = creditor.get('name')
    creditor_acc = txn_data.get('creditor_account')
    creditor_iban = _extract_account_iban(creditor_acc) if creditor_acc else None
    creditor_address = _extract_address(creditor.get('postal_address'))
    
    # Debtor info
    debtor = txn_data.get('debtor') or {}
    debtor_name = debtor.get('name')
    debtor_acc = txn_data.get('debtor_account')
    debtor_iban = _extract_account_iban(debtor_acc) if debtor_acc else None
    debtor_address = _extract_address(debtor.get('postal_address'))
    
    # Remittance information
    remittance = txn_data.get('remittance_information') or []
    if isinstance(remittance, str):
        remittance = [remittance]
    
    # Bank transaction code
    bank_txn_code_obj = txn_data.get('bank_transaction_code')
    bank_txn_code = None
    if bank_txn_code_obj and isinstance(bank_txn_code_obj, dict):
        bank_txn_code = bank_txn_code_obj.get('code')
    
    # Balance after transaction
    balance_obj = txn_data.get('balance_after_transaction')
    balance_after = None
    if balance_obj:
        balance_after = _parse_decimal(balance_obj.get('amount'))
    
    return EnableBankingTransaction(
        entry_reference=entry_ref,
        amount=amount,
        currency=currency,
        credit_debit_indicator=indicator,
        booking_date=booking_date,
        transaction_date=transaction_date,
        value_date=value_date,
        status=txn_data.get('status', 'BOOK'),
        creditor_name=creditor_name,
        creditor_iban=creditor_iban,
        creditor_address=creditor_address,
        debtor_name=debtor_name,
        debtor_iban=debtor_iban,
        debtor_address=debtor_address,
        remittance_information=remittance,
        bank_transaction_code=bank_txn_code,
        balance_after=balance_after,
        account_id=account_id,
        bank=bank,
    )


def _generate_transaction_id(txn: EnableBankingTransaction) -> str:
    """Generate unique transaction ID from entry_reference."""
    # entry_reference should be unique per bank, but add bank prefix for safety
    return f"{txn.bank}:{txn.entry_reference}"


def get_info(txn: EnableBankingTransaction) -> dict:
    """Create info dict for import result."""
    return dict(
        type='application/json',
        filename=f"{txn.bank}/transactions_{txn.account_id}.json",
    )


class EnableBankingSource(Source):
    """EnableBanking JSON transaction source."""

    def __init__(
        self,
        directory: str,
        account_map: Optional[Dict[str, str]] = None,
        default_account: Optional[str] = None,
        banks: Optional[List[str]] = None,
        **kwargs,
    ) -> None:
        """Initialize the EnableBanking source.

        Args:
            directory: Directory containing bank subdirectories with JSON files.
            account_map: Dictionary mapping account_id (IBAN_CURRENCY) to Beancount account.
            default_account: Fallback account when account not in account_map.
            banks: Optional list of bank subdirectory names to import (e.g., ['mbank', 'revolut']).
                   If not specified, all bank subdirectories are imported.
            **kwargs: Additional arguments passed to Source.
        """
        super().__init__(**kwargs)
        self.data_directory = directory
        
        self.account_map: Dict[str, str] = account_map or {}
        self.default_account = default_account
        self.banks = banks  # None means all banks
        
        if not self.default_account and not self.account_map:
            raise ValueError(
                "EnableBankingSource requires either 'account_map' or "
                "'default_account' to be specified."
            )

        # Store loaded data
        self.accounts: List[EnableBankingAccount] = []
        self.transactions: List[EnableBankingTransaction] = []
        
        # Load all data
        self._load_all_data()

    def _load_all_data(self) -> None:
        """Load all data from bank subdirectories."""
        if not os.path.isdir(self.data_directory):
            self.log_status(f'enablebanking: directory not found: {self.data_directory}')
            return
        
        # Find bank subdirectories
        for bank_name in os.listdir(self.data_directory):
            bank_path = os.path.join(self.data_directory, bank_name)
            if not os.path.isdir(bank_path):
                continue
            
            # Filter by banks list if specified
            if self.banks is not None and bank_name not in self.banks:
                continue
            
            # Load accounts.json
            accounts_path = os.path.join(bank_path, 'accounts.json')
            if os.path.exists(accounts_path):
                self._load_accounts(accounts_path, bank_name)
            
            # Load transaction files
            for filename in os.listdir(bank_path):
                if filename.startswith('transactions_') and filename.endswith('.json'):
                    txn_path = os.path.join(bank_path, filename)
                    # Extract account_id from filename: transactions_IBAN_CURRENCY.json
                    account_id = filename[len('transactions_'):-len('.json')]
                    self._load_transactions(txn_path, account_id, bank_name)
        
        self.log_status(
            f'enablebanking: loaded {len(self.accounts)} accounts, '
            f'{len(self.transactions)} transactions'
        )

    def _load_accounts(self, path: str, bank_name: str) -> None:
        """Load accounts from accounts.json file."""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            self.log_status(f'enablebanking: error loading {path}: {e}')
            return
        
        aspsp_id = data.get('aspsp_id', bank_name)
        
        for acc_data in data.get('accounts', []):
            account_id_obj = acc_data.get('account_id', {})
            iban = _extract_account_iban(account_id_obj)
            if not iban:
                continue
            
            currency = acc_data.get('currency', 'PLN')
            account_id = f"{iban}_{currency}"
            
            self.accounts.append(EnableBankingAccount(
                iban=iban,
                currency=currency,
                name=acc_data.get('name', ''),
                product=acc_data.get('product'),
                bank=aspsp_id,
                account_id=account_id,
            ))

    def _load_transactions(self, path: str, account_id: str, bank_name: str) -> None:
        """Load transactions from a transactions_*.json file."""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            self.log_status(f'enablebanking: error loading {path}: {e}')
            return
        
        # Find bank name from accounts if available
        actual_bank = bank_name
        for acc in self.accounts:
            if acc.account_id == account_id:
                actual_bank = acc.bank
                break
        
        for txn_data in data.get('transactions', []):
            txn = _parse_transaction(txn_data, account_id, actual_bank)
            if txn:
                self.transactions.append(txn)

    def _get_account_for_id(self, account_id: str) -> Optional[str]:
        """Get the Beancount account for a given account_id.
        
        Returns None if account is not mapped and no default_account is set.
        """
        if account_id in self.account_map:
            return self.account_map[account_id]
        return self.default_account  # None if not set

    def _get_all_accounts(self) -> set:
        """Get all accounts used by this source."""
        accounts = set(self.account_map.values())
        if self.default_account:
            accounts.add(self.default_account)
        return accounts

    def get_example_key_value_pairs(
        self,
        transaction: Transaction,
        posting: Posting,
    ) -> dict:
        """Extract key-value pairs for account prediction."""
        result = {}
        if posting.meta is None:
            return result
        
        def maybe_add_key(key: str) -> None:
            value = posting.meta.get(key)
            if value is not None:
                result[key] = value
        
        maybe_add_key(TRANSACTION_TYPE_KEY)
        maybe_add_key(COUNTERPARTY_KEY)
        maybe_add_key(TITLE_KEY)

        return result

    def is_posting_cleared(self, posting: Posting) -> bool:
        """Check if a posting is cleared."""
        if posting.meta is None:
            return False
        return SOURCE_REF_KEY in posting.meta

    def prepare(
        self,
        journal: JournalEditor,
        results: SourceResults,
    ) -> None:
        """Prepare import results from loaded transactions."""
        all_accounts = self._get_all_accounts()

        # Build set of already-matched transaction IDs
        matched_ids: Dict[str, List[Tuple[Transaction, Posting]]] = {}

        for entry in journal.all_entries:
            if not isinstance(entry, Transaction):
                continue
            for posting in entry.postings:
                if posting.meta is None:
                    continue
                if posting.account not in all_accounts:
                    continue
                ref = posting.meta.get(SOURCE_REF_KEY)
                if ref is not None:
                    matched_ids.setdefault(ref, []).append((entry, posting))

        # Group transactions by account for balance assertions
        txns_by_account: Dict[str, List[EnableBankingTransaction]] = {}
        
        # Process all transactions
        valid_ids = set()
        for txn in self.transactions:
            txn_id = _generate_transaction_id(txn)
            valid_ids.add(txn_id)

            existing = matched_ids.get(txn_id)
            if existing is not None:
                if len(existing) > 1:
                    results.add_invalid_reference(
                        InvalidSourceReference(len(existing) - 1, existing))
            else:
                # Create new transaction
                target_account = self._get_account_for_id(txn.account_id)
                # Skip if account is not mapped and no default_account
                if target_account is None:
                    continue
                beancount_txn = self._make_transaction(txn, target_account)
                results.add_pending_entry(
                    ImportResult(
                        date=txn.booking_date,
                        entries=[beancount_txn],
                        info=get_info(txn),
                    ))
            
            # Track for balance assertions (only for mapped accounts)
            target_account = self._get_account_for_id(txn.account_id)
            if target_account is None:
                continue
            if txn.account_id not in txns_by_account:
                txns_by_account[txn.account_id] = []
            txns_by_account[txn.account_id].append(txn)

        # Generate monthly balance assertions from transactions with balance_after
        # For each account, group transactions by month and generate balance at end of each month
        # Only generate for completed months (not the current month)
        today = datetime.date.today()
        current_year_month = (today.year, today.month)
        
        for account_id, txns in txns_by_account.items():
            target_account = self._get_account_for_id(account_id)
            # Skip if account is not mapped
            if target_account is None:
                continue
            
            # Sort by date AND entry_reference (for correct order within same day)
            txns.sort(key=lambda t: (t.booking_date, t.entry_reference))
            
            # Group transactions by year-month
            # Find the last transaction with balance_after for each month
            monthly_balances: Dict[Tuple[int, int], EnableBankingTransaction] = {}
            
            for txn in txns:
                if txn.balance_after is not None:
                    year_month = (txn.booking_date.year, txn.booking_date.month)
                    # Keep updating - the last one in the month will be kept
                    monthly_balances[year_month] = txn
            
            # Generate balance assertion for each completed month
            for (year, month), txn in monthly_balances.items():
                # Skip current month - it's not complete yet
                if (year, month) == current_year_month:
                    continue
                
                # Balance date is the 1st of the next month
                if month == 12:
                    balance_date = datetime.date(year + 1, 1, 1)
                else:
                    balance_date = datetime.date(year, month + 1, 1)
                
                results.add_pending_entry(
                    ImportResult(
                        date=balance_date,
                        entries=[
                            Balance(
                                date=balance_date,
                                meta=None,
                                account=target_account,
                                amount=Amount(txn.balance_after, txn.currency),
                                tolerance=None,
                                diff_amount=None,
                            )
                        ],
                        info=get_info(txn),
                    ))

        # Check for invalid references
        for ref, postings in matched_ids.items():
            if ref not in valid_ids:
                results.add_invalid_reference(
                    InvalidSourceReference(len(postings), postings))

        # Register all accounts
        for account in all_accounts:
            results.add_account(account)

    def _make_transaction(
        self, 
        txn: EnableBankingTransaction, 
        target_account: str,
    ) -> Transaction:
        """Create a Beancount Transaction from an EnableBanking transaction."""
        txn_id = _generate_transaction_id(txn)

        # Build metadata
        meta = collections.OrderedDict([
            (SOURCE_REF_KEY, txn_id),
            (SOURCE_BANK_KEY, txn.bank),
        ])
        
        # Add own account IBAN (extract from account_id format: IBAN_CURRENCY)
        account_iban = txn.account_id.rsplit('_', 1)[0] if '_' in txn.account_id else txn.account_id
        meta[ACCOUNT_IBAN_KEY] = account_iban

        # Determine counterparty based on credit/debit
        counterparty = None
        counterparty_address = None
        counterparty_iban = None
        if txn.credit_debit_indicator == 'CRDT':
            # Incoming - debtor is the counterparty
            counterparty, addr_from_name = _split_counterparty_address(txn.debtor_name)
            counterparty_iban = txn.debtor_iban
            # Prefer postal_address over address embedded in name
            counterparty_address = txn.debtor_address or addr_from_name
        else:
            # Outgoing - creditor is the counterparty
            counterparty, addr_from_name = _split_counterparty_address(txn.creditor_name)
            counterparty_iban = txn.creditor_iban
            # Prefer postal_address over address embedded in name
            counterparty_address = txn.creditor_address or addr_from_name

        if counterparty:
            meta[COUNTERPARTY_KEY] = counterparty
        if counterparty_address:
            meta[COUNTERPARTY_ADDRESS_KEY] = counterparty_address
        if counterparty_iban:
            # Use IBAN or BBAN key based on whether it has country prefix
            if counterparty_iban.startswith(('PL', 'LT', 'DE', 'GB', 'FR')):
                meta[COUNTERPARTY_IBAN_KEY] = counterparty_iban
            else:
                meta[COUNTERPARTY_BBAN_KEY] = counterparty_iban
        
        # Add booking_date (when bank recorded it)
        meta[BOOKING_DATE_KEY] = txn.booking_date
        
        # Add transaction_date if different from booking_date (as proper date object for matching)
        if txn.transaction_date and txn.transaction_date != txn.booking_date:
            meta[TRANSACTION_DATE_KEY] = txn.transaction_date  # datetime.date, not string!
        
        # Note: transaction_type and title are set later after rules are applied

        # Validate amount before creating Amount
        if not isinstance(txn.amount, Decimal):
            print(f"[enablebanking] ERROR in _make_transaction: txn.amount is {type(txn.amount)}, not Decimal: {txn.amount}")
            print(f"[enablebanking] Transaction: {txn.entry_reference} from {txn.bank}")
            # Try to convert to Decimal
            try:
                txn_amount = D(str(txn.amount))
            except Exception as e:
                print(f"[enablebanking] Cannot convert: {e}")
                raise
        else:
            txn_amount = txn.amount
        
        # Ensure currency is a string
        if not isinstance(txn.currency, str):
            print(f"[enablebanking] ERROR: txn.currency is {type(txn.currency)}, not str: {txn.currency}")
            txn_currency = str(txn.currency)
        else:
            txn_currency = txn.currency

        amount = Amount(txn_amount, txn_currency)
        neg_amount = Amount(-txn_amount, txn_currency)
        
        # Additional validation
        if not isinstance(amount.number, Decimal):
            print(f"[enablebanking] ERROR: amount.number is {type(amount.number)}: {amount}")
        if not isinstance(neg_amount.number, Decimal):
            print(f"[enablebanking] ERROR: neg_amount.number is {type(neg_amount.number)}: {neg_amount}")

        # Determine payee, narration, and transaction_type
        # First try bank-specific and generic rules
        parsed = get_parsed_transaction(txn)
        if parsed:
            payee = parsed.payee
            narration = parsed.narration
            # Set transaction_type from parsed result (already validated)
            # Fallback to bank_transaction_code only if it's a known type
            if parsed.transaction_type:
                meta[TRANSACTION_TYPE_KEY] = parsed.transaction_type
            elif txn.bank_transaction_code and txn.bank_transaction_code in KNOWN_TRANSACTION_TYPES:
                meta[TRANSACTION_TYPE_KEY] = txn.bank_transaction_code
            
            # Handle metadata based on where payee comes from:
            # - If counterparty from JSON exists: it's already in metadata, title = first remittance line
            # - If payee extracted from remittance[0] (no JSON counterparty): 
            #   that's the counterparty, no separate title
            if counterparty:
                # Counterparty from JSON - first remittance line is the title/description
                if txn.remittance_information:
                    meta[TITLE_KEY] = txn.remittance_information[0]
            else:
                # No counterparty from JSON - payee was extracted from remittance[0]
                # Store it as counterparty metadata (it's the merchant/payee)
                if payee and payee != txn.bank:
                    meta[COUNTERPARTY_KEY] = payee
                # No title in this case (the "title" IS the counterparty)
        else:
            # Fallback to basic logic (should rarely happen with generic rules)
            payee = counterparty or txn.bank
            if txn.remittance_information:
                narration = txn.remittance_information[0]
                meta[TITLE_KEY] = txn.remittance_information[0]
            elif txn.bank_transaction_code:
                narration = txn.bank_transaction_code
            else:
                narration = 'Transaction'
            # Only set transaction_type if it's a known type
            if txn.bank_transaction_code and txn.bank_transaction_code in KNOWN_TRANSACTION_TYPES:
                meta[TRANSACTION_TYPE_KEY] = txn.bank_transaction_code

        return Transaction(
            meta=None,
            date=txn.booking_date,
            flag=FLAG_OKAY,
            payee=payee,
            narration=narration,
            tags=EMPTY_SET,
            links=EMPTY_SET,
            postings=[
                Posting(
                    account=target_account,
                    units=amount,
                    cost=None,
                    price=None,
                    flag=None,
                    meta=meta,
                ),
                Posting(
                    account=FIXME_ACCOUNT,
                    units=neg_amount,
                    cost=None,
                    price=None,
                    flag=None,
                    meta=None,
                ),
            ],
        )

    @property
    def name(self) -> str:
        """Return the source name."""
        return 'enablebanking'


def load(spec: dict, log_status) -> EnableBankingSource:
    """Load the EnableBanking source.

    Args:
        spec: Configuration dictionary.
        log_status: Logging function.

    Returns:
        Configured EnableBankingSource instance.
    """
    return EnableBankingSource(log_status=log_status, **spec)
