"""Trading 212 file-based transaction source.

Imports transactions from Trading 212 by reading JSON files exported by finance-dl.

To use, first run the finance-dl Trading 212 exporter to download data from the API,
then configure this source to read from the output directory.

Example configuration:

    dict(
        module="beancount_import.source.trading212",
        data_directory="/path/to/trading212/data",  # Directory with JSON files
        cash_account="Assets:Trading212:Cash",
        investment_account="Assets:Trading212",
        dividend_income_account="Income:Dividends",
        capital_gains_account="Income:Capital-Gains",
        fees_account="Expenses:Fees:Trading",
        transfer_account="Assets:FIXME",
    )

The importer will generate transactions for:
- Buy/Sell orders
- Dividends
- Deposits/Withdrawals
- Fees
- Lending interest (from CSV exports)
- Interest on cash (from CSV exports)

Balance assertions will be generated for:
- Current positions (stocks)
- Cash balance

Primary data source: CSV exports (export_*.csv) from Trading212.
Supplementary JSON files (generated by finance-dl):
- positions.json: Current open positions (for reconciliation)
- account_summary.json: Current account state (for cash balance verification)
- pending_orders.json: Active/pending orders (for forecasting) [optional]
- instruments.json: Instrument metadata [optional]
- pies.json: Pie details and ticker mappings [optional]
- corporate_actions.json: Stock splits not in CSV [optional, user-maintained]

DEPRECATED (no longer used - all data comes from CSV):
- orders.json, dividends.json, transactions.json
"""


import csv
import datetime
import glob
import hashlib
import json
import os
from dataclasses import dataclass, asdict
from decimal import Decimal
from typing import (
    Callable,
    Dict,
    List,
    Optional,
    Sequence,
    Tuple,
    TypedDict,
    Union,
)


from beancount.core.amount import Amount
from beancount.core.data import Balance, Commodity, Custom, Directive, Document, Open, Posting, Price, Transaction, TxnPosting, EMPTY_SET
from beancount.core.number import D

from beancount_import.journal_editor import JournalEditor
from beancount_import.matching import FIXME_ACCOUNT
from beancount_import.posting_date import POSTING_DATE_KEY
from beancount_import.source import ImportResult, InvalidSourceReference, SourceResults
from beancount_import.source.description_based_source import (
    SOURCE_DESC_KEYS,
    DescriptionBasedSource,
    get_posting_source_descs,
)
from beancount_import.unbook import group_postings_by_meta, unbook_postings


# Metadata keys (standardized across all bank sources)
SOURCE_KEY = 'source'  # Source/provider identifier (e.g., "trading212")
SOURCE_REF_KEY = 'source_ref'  # Raw transaction reference ID from export
TRANSACTION_TYPE_KEY = 'transaction_type'  # Transaction type
TICKER_KEY = 'ticker'  # Stock ticker
ISIN_KEY = 'isin'  # ISIN code
INSTRUMENT_NAME_KEY = 'instrument_name'  # Instrument name
SOURCE_DOC_KEY = 'document'  # Link to source document file

# Source identifier for this importer
SOURCE_ID = 'trading212'


class Trading212DataError(Exception):
    """Exception raised when data files cannot be loaded or parsed."""
    pass


@dataclass
class ApiOrder:
    """Parsed order from Trading 212 API."""
    order_id: int
    ticker: str
    isin: str
    name: str
    side: str  # BUY or SELL
    status: str
    quantity: Decimal
    filled_quantity: Decimal
    filled_price: Optional[Decimal]
    filled_at: Optional[datetime.datetime]
    created_at: datetime.datetime
    currency: str  # Instrument currency
    account_currency: str  # Account currency
    fx_rate: Optional[Decimal]
    net_value: Optional[Decimal]  # In account currency
    realized_pnl: Optional[Decimal]
    taxes: List[Tuple[str, Decimal]]  # List of (tax_name, amount)


@dataclass
class ApiDividend:
    """Parsed dividend from Trading 212 API."""
    reference: str
    ticker: str
    isin: str
    name: str
    paid_on: datetime.date
    quantity: Decimal
    amount: Decimal  # In account currency
    amount_per_share: Decimal  # In instrument currency
    currency: str  # Account currency
    ticker_currency: str  # Instrument currency
    dividend_type: str


@dataclass
class ApiTransaction:
    """Parsed transaction (deposit/withdrawal/fee) from Trading 212 API."""
    reference: str
    transaction_type: str  # DEPOSIT, WITHDRAW, FEE, TRANSFER
    amount: Decimal
    currency: str
    date_time: datetime.datetime


@dataclass
class ApiPosition:
    """Current position from Trading 212 API."""
    ticker: str
    isin: str
    name: str
    quantity: Decimal
    average_price: Decimal
    current_price: Decimal
    currency: str  # Instrument currency
    total_cost: Decimal  # In account currency
    current_value: Decimal  # In account currency


@dataclass
class ApiAccountSummary:
    """Account summary from Trading 212 API."""
    account_id: int
    currency: str
    cash_available: Decimal
    cash_in_pies: Decimal
    cash_reserved: Decimal
    investments_value: Decimal
    total_value: Decimal


@dataclass
class ApiPie:
    """Pie (portfolio) from Trading 212 API."""
    pie_id: int
    cash: Decimal
    progress: Optional[Decimal]
    status: Optional[str]  # AHEAD, ON_TRACK, BEHIND
    dividend_gained: Decimal
    dividend_reinvested: Decimal


@dataclass
class ApiPieDetail:
    """Detailed pie information with instruments."""
    pie_id: int
    name: str  # From settings.icon or derived
    goal: Optional[Decimal]
    creation_date: Optional[datetime.date]
    dividend_action: str  # REINVEST or TO_ACCOUNT_CASH
    tickers: List[str]  # List of tickers in this pie


@dataclass
class CommodityInfo:
    """Information about a commodity for beancount declaration."""
    symbol: str  # Beancount symbol (e.g., "AAPL", "WTAI.LSE")
    name: str  # Full instrument name
    isin: str  # ISIN code
    ticker: str  # Primary ticker (for Yahoo Finance lookup)
    csv_ticker: str  # Ticker from CSV exports (e.g., "AAPL")
    api_ticker: str  # Ticker from API/instruments.json (e.g., "AAPL_US_EQ")
    currency: str  # Instrument currency
    exchange_name: str  # Full exchange name (e.g., "NASDAQ", "London Stock Exchange")
    exchange_code: str  # 3-letter exchange code (e.g., "NMS", "LSE")
    yahoo_suffix: str  # Yahoo Finance suffix (e.g., ".L", ".DE", "")
    asset_class: str  # "stock", "etf", etc.


@dataclass
class CorporateAction:
    """Corporate action (split, reverse split, merger, etc.) not in CSV exports."""
    isin: str
    ticker: str
    action_type: str  # "split", "reverse_split", "merger", "delisting", "spinoff"
    date: datetime.date
    ratio_from: int  # e.g., 30 for 30:1 reverse split
    ratio_to: int    # e.g., 1 for 30:1 reverse split
    note: Optional[str] = None


# Exchange information: (full_name, 3-letter code, yahoo_suffix)
EXCHANGE_INFO = {
    # Trading 212 suffix → (Full Name, Code, Yahoo Suffix)
    "l": ("London Stock Exchange", "LSE", ".L"),
    "m": ("Borsa Italiana", "MIL", ".MI"),
    "d": ("XETRA", "FRA", ".DE"),
    "f": ("Euronext Paris", "EPA", ".PA"),
    "s": ("Bolsa de Madrid", "BME", ".MC"),
    "a": ("ASX", "ASX", ".AX"),
    "h": ("Hong Kong Stock Exchange", "HKG", ".HK"),
    "t": ("Tokyo Stock Exchange", "TYO", ".T"),
    "c": ("Toronto Stock Exchange", "TSE", ".TO"),
    "b": ("Euronext Brussels", "EBR", ".BR"),
    "n": ("Euronext Amsterdam", "AMS", ".AS"),
}



def _get_exchange_from_ticker(ticker: str, isin: Optional[str] = None) -> Tuple[str, str, str]:
    """Determine the exchange from Trading 212 ticker format.
    
    Only returns exchange info when we can definitively determine it from
    the ticker suffix. Does NOT guess based on ticker length or other heuristics.
    
    Args:
        ticker: Trading 212 ticker (e.g., "AAPL_US_EQ", "WTAIl_EQ")
        isin: Optional ISIN (currently unused, kept for API compatibility)
    
    Returns:
        Tuple of (full_name, 3-letter code, yahoo_suffix)
        Returns ("", "", "") if exchange cannot be determined with certainty
    """
    # Check for exchange suffix (lowercase letter before _EQ)
    exchange_suffix = _get_exchange_suffix(ticker)
    if exchange_suffix and exchange_suffix in EXCHANGE_INFO:
        return EXCHANGE_INFO[exchange_suffix]
    
    # Cannot determine exchange with certainty - return empty
    return ("", "", "")




def _parse_iso_datetime(s: Optional[str]) -> Optional[datetime.datetime]:
    """Parse an ISO 8601 datetime string."""
    if not s:
        return None
    # Handle various ISO formats
    s = s.replace("Z", "+00:00")
    try:
        return datetime.datetime.fromisoformat(s)
    except ValueError:
        return None


def _parse_date(s: Optional[str]) -> Optional[datetime.date]:
    """Parse a date string (ISO format)."""
    if not s:
        return None
    try:
        return datetime.date.fromisoformat(s[:10])
    except ValueError:
        return None


def _ticker_to_base_symbol(ticker: str) -> str:
    """Extract base symbol from Trading 212 ticker (without exchange suffix).
    
    Trading 212 uses tickers like:
    - "AAPL_US_EQ" for US stocks → "AAPL"
    - "WTAIl_EQ" for European ETFs (lowercase 'l' = London) → "WTAI"
    - "BAl_EQ" for UK stocks → "BA"
    
    The lowercase letter suffix indicates the exchange/market.
    """
    if "_" in ticker:
        symbol = ticker.split("_")[0]
    else:
        symbol = ticker
    
    # Strip lowercase exchange suffix (e.g., 'l' for London, 'd' for Germany)
    # These are single lowercase letters at the end of otherwise uppercase symbols
    if len(symbol) > 1 and symbol[-1].islower() and symbol[:-1].isupper():
        symbol = symbol[:-1]
    
    return symbol


def _get_exchange_suffix(ticker: str) -> Optional[str]:
    """Extract exchange suffix from Trading 212 ticker.
    
    Returns the lowercase letter suffix if present (e.g., 'l' for London),
    or None for US stocks.
    """
    if "_" in ticker:
        symbol = ticker.split("_")[0]
    else:
        symbol = ticker
    
    if len(symbol) > 1 and symbol[-1].islower() and symbol[:-1].isupper():
        return symbol[-1]
    
    return None


def _ticker_to_symbol(ticker: str, currency: Optional[str] = None, account_currency: str = "USD", 
                       include_exchange: bool = False, isin: Optional[str] = None) -> str:
    """Convert Trading 212 ticker to a beancount symbol.
    
    Args:
        ticker: Trading 212 ticker (e.g., "AAPL_US_EQ", "WTAIl_EQ")
        currency: Instrument currency (e.g., "USD", "GBX", "EUR")
        account_currency: Account base currency (default "USD")
        include_exchange: If True, always include exchange suffix (for duplicates)
        isin: Optional ISIN to help determine exchange
    
    Returns:
        Symbol suitable for beancount (e.g., "AAPL", "WTAI.LSE")
    """
    base_symbol = _ticker_to_base_symbol(ticker)
    
    if include_exchange:
        _, exchange_code, _ = _get_exchange_from_ticker(ticker, isin)
        if exchange_code:
            return f"{base_symbol}.{exchange_code}"
    
    return base_symbol


# ------------------------------------------------------------------
# Entry generation
# ------------------------------------------------------------------

@dataclass
class OrderEntry:
    """A processed order ready to become a beancount transaction."""
    order: ApiOrder
    
    def get_date(self) -> datetime.date:
        if self.order.filled_at:
            return self.order.filled_at.date()
        return self.order.created_at.date()
    
    def get_source_desc(self) -> str:
        symbol = _ticker_to_base_symbol(self.order.ticker)
        return f"{self.order.side} {symbol} {self.order.filled_quantity} @ {self.order.filled_price}"
    
    def get_meta_key(self) -> str:
        return SOURCE_REF_KEY
    
    def get_meta_value(self) -> str:
        return str(self.order.order_id)


@dataclass  
class DividendEntry:
    """A processed dividend ready to become a beancount transaction."""
    dividend: ApiDividend
    
    def get_date(self) -> datetime.date:
        return self.dividend.paid_on
    
    def get_source_desc(self) -> str:
        symbol = _ticker_to_base_symbol(self.dividend.ticker)
        return f"Dividend {symbol} {self.dividend.amount} {self.dividend.currency}"
    
    def get_meta_key(self) -> str:
        return SOURCE_REF_KEY
    
    def get_meta_value(self) -> str:
        return self.dividend.reference


@dataclass
class TransactionEntry:
    """A processed cash transaction ready to become a beancount transaction."""
    transaction: ApiTransaction
    
    def get_date(self) -> datetime.date:
        return self.transaction.date_time.date()
    
    def get_source_desc(self) -> str:
        return f"{self.transaction.transaction_type} {self.transaction.amount} {self.transaction.currency}"
    
    def get_meta_key(self) -> str:
        return SOURCE_REF_KEY
    
    def get_meta_value(self) -> str:
        return self.transaction.reference


# ------------------------------------------------------------------
# Source implementation
# ------------------------------------------------------------------

class Trading212SourceSpecDict(TypedDict, total=False):
    directory: str  # Directory containing JSON files from finance-dl
    cash_account: str
    investment_account: str
    dividend_income_account: str
    capital_gains_account: str
    fees_account: str
    transfer_account: str
    lending_income_account: str  # For stock lending interest
    interest_income_account: str  # For interest on cash
    commodity_output: str  # Path to output commodities.beancount


LogStatusCallable = Callable[[str], None]


def load(spec: Trading212SourceSpecDict, log_status: LogStatusCallable):
    return Trading212Source(**spec, log_status=log_status)


@dataclass
class CsvTransaction:
    """Parsed transaction from Trading 212 CSV export."""
    action: str
    time: datetime.datetime
    isin: Optional[str]
    ticker: Optional[str]
    name: Optional[str]
    notes: Optional[str]
    transaction_id: str
    num_shares: Optional[Decimal]
    price_per_share: Optional[Decimal]
    price_currency: Optional[str]  # Currency (Price / share)
    exchange_rate: Optional[Decimal]
    result: Optional[Decimal]  # P&L result
    result_currency: Optional[str]  # Currency (Result)
    currency: str  # Currency (Total)
    total: Decimal
    withholding_tax: Optional[Decimal]
    withholding_tax_currency: Optional[str]
    charge_amount: Optional[Decimal]
    charge_currency: Optional[str]
    deposit_fee: Optional[Decimal]
    deposit_fee_currency: Optional[str]
    # Fee fields
    stamp_duty: Optional[Decimal]
    stamp_duty_currency: Optional[str]
    transaction_fee: Optional[Decimal]
    transaction_fee_currency: Optional[str]
    finra_fee: Optional[Decimal]
    finra_fee_currency: Optional[str]
    # Source file
    source_file: Optional[str] = None  # CSV filename this transaction came from


class Trading212Source(DescriptionBasedSource):
    name = "trading212"

    def __init__(
        self,
        directory: str,  # Directory containing JSON files from finance-dl
        cash_account: str = "Assets:Trading212:Cash",
        investment_account: str = "Assets:Trading212",
        dividend_income_account: str = "Income:Dividends",
        capital_gains_account: str = "Income:Capital-Gains",
        fees_account: str = "Expenses:Fees:Trading",
        transfer_account: str = "Assets:FIXME",
        # Accounts for CSV-specific transaction types
        lending_income_account: str = "Income:Lending",
        interest_income_account: str = "Income:Interest",
        commodity_output: Optional[str] = None,  # Path to output commodities.beancount
        log_status: LogStatusCallable = lambda x: None,
        **kwargs,  # Accept extra config params (e.g., 'description')
    ) -> None:
        super().__init__(log_status)
        self.data_directory = directory
        self.cash_account = cash_account
        self.investment_account = investment_account
        self.dividend_income_account = dividend_income_account
        self.capital_gains_account = capital_gains_account
        self.fees_account = fees_account
        self.transfer_account = transfer_account
        self.lending_income_account = lending_income_account
        self.interest_income_account = interest_income_account
        self.commodity_output = commodity_output
        
        # Debug logging for account configuration
        print(f"[Trading212] Account configuration:", flush=True)
        print(f"  cash_account: {self.cash_account}", flush=True)
        print(f"  investment_account: {self.investment_account}", flush=True)
        print(f"  dividend_income_account: {self.dividend_income_account}", flush=True)
        print(f"  capital_gains_account: {self.capital_gains_account}", flush=True)
        
        # Verify data directory exists
        if not os.path.isdir(directory):
            raise Trading212DataError(f"Data directory does not exist: {directory}")
        
        
        # Data loaded from files (orders, dividends, transactions are now from CSV only)
        self._pending_orders: Optional[List[ApiOrder]] = None  # Active/pending orders (forecast)
        self._positions: Optional[List[ApiPosition]] = None
        self._positions_fetched_at: Optional[datetime.datetime] = None  # Datetime when positions were fetched
        self._account_summary: Optional[ApiAccountSummary] = None
        self._account_summary_fetched_at: Optional[datetime.date] = None  # Date when account summary was fetched
        self._ticker_to_pie: Optional[Dict[str, List[str]]] = None  # Ticker to pie names mapping
        self._csv_transactions: Optional[List[CsvTransaction]] = None  # Primary source for all transactions
        self._instruments: Optional[Dict[str, dict]] = None  # Ticker -> instrument info from instruments.json
        self._corporate_actions: Optional[List[CorporateAction]] = None  # Corporate actions from config file
        
        # Symbol registry: maps base_symbol -> list of (ticker, isin) tuples
        # Used to detect when same base symbol is used on multiple exchanges
        self._symbol_registry: Dict[str, List[Tuple[str, str]]] = {}
        # Maps original ticker -> final beancount symbol
        self._ticker_to_beancount_symbol: Dict[str, str] = {}

    def _get_data_file_path(self, name: str) -> str:
        """Get path to a data file in the data directory."""
        return os.path.join(self.data_directory, f"{name}.json")

    def _load_json_file(self, name: str) -> Optional[dict]:
        """Load a JSON file from the data directory."""
        path = self._get_data_file_path(name)
        if not os.path.exists(path):
            return None
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"[Trading212] Error loading {name}.json: {e}", flush=True)
            return None

    def _load_all_data(self) -> None:
        """Load all data from JSON files in data_directory."""
        print("\n" + "="*60, flush=True)
        print("[Trading212] Loading data from files", flush=True)
        print(f"[Trading212] Data directory: {self.data_directory}", flush=True)
        print("="*60, flush=True)
        
        # NOTE: orders.json, dividends.json, transactions.json are no longer used
        # All transaction data comes from CSV exports which are more complete and accurate
        # JSON files that are still used:
        # - pending_orders.json: Active/pending orders (for forecasting)
        # - positions.json: Current positions (for reconciliation)
        # - account_summary.json: Account cash balance (for verification)
        # - instruments.json: Commodity metadata (for beancount declarations)
        # - pies.json: Pie allocations (for tagging)
        # - corporate_actions.json: Stock splits etc. not in CSV
        
        # Load pending orders (these are still useful for forecasting)
        if self._pending_orders is None:
            print("\n[Trading212] === PENDING ORDERS ===", flush=True)
            data = self._load_json_file("pending_orders")
            if data and "items" in data:
                self._pending_orders = [self._dict_to_order(item) for item in data["items"]]
                print(f"[Trading212] ✓ {len(self._pending_orders)} pending orders loaded", flush=True)
            else:
                self._pending_orders = []
                print("[Trading212] No pending_orders.json (this is normal)", flush=True)
        
        # Load positions
        if self._positions is None:
            print("\n[Trading212] === POSITIONS ===", flush=True)
            data = self._load_json_file("positions")
            if data and "items" in data:
                self._positions = [self._dict_to_position(item) for item in data["items"]]
                # Parse fetched_at date
                if "fetched_at" in data:
                    fetched_at = datetime.datetime.fromisoformat(data["fetched_at"])
                    self._positions_fetched_at = fetched_at  # Store full datetime for hour-based price date logic
                print(f"[Trading212] ✓ {len(self._positions)} positions loaded", flush=True)
            else:
                print("[Trading212] ✗ positions.json not found or empty", flush=True)
                self._positions = []
        
        # Load account summary
        if self._account_summary is None:
            print("\n[Trading212] === ACCOUNT SUMMARY ===", flush=True)
            data = self._load_json_file("account_summary")
            if data:
                self._account_summary = ApiAccountSummary(
                    account_id=data.get("account_id", 0),
                    currency=data.get("currency", "EUR"),
                    cash_available=D(str(data.get("cash_available", 0))),
                    cash_in_pies=D(str(data.get("cash_in_pies", 0))),
                    cash_reserved=D(str(data.get("cash_reserved", 0))),
                    investments_value=D(str(data.get("investments_value", 0))),
                    total_value=D(str(data.get("total_value", 0))),
                )
                # Parse fetched_at date
                if "fetched_at" in data:
                    fetched_at = datetime.datetime.fromisoformat(data["fetched_at"])
                    self._account_summary_fetched_at = fetched_at.date()
                print(f"[Trading212] ✓ Account: {self._account_summary.currency} {self._account_summary.total_value}", flush=True)
            else:
                print("[Trading212] ✗ account_summary.json not found", flush=True)
        
        # Load pie mapping
        if self._ticker_to_pie is None:
            print("\n[Trading212] === PIES ===", flush=True)
            data = self._load_json_file("pies")
            if data and "ticker_to_pie" in data:
                self._ticker_to_pie = data["ticker_to_pie"]
                print(f"[Trading212] ✓ {len(self._ticker_to_pie)} tickers mapped to pies", flush=True)
            else:
                self._ticker_to_pie = {}
                print("[Trading212] No pies data (this is normal)", flush=True)
        
        # Load instruments metadata (optional but useful for commodity declarations)
        if self._instruments is None:
            print("\n[Trading212] === INSTRUMENTS ===", flush=True)
            data = self._load_json_file("instruments")
            if data and "items" in data:
                # Index by ticker for quick lookup
                self._instruments = {item["ticker"]: item for item in data["items"]}
                print(f"[Trading212] ✓ {len(self._instruments)} instruments loaded", flush=True)
            else:
                self._instruments = {}
                print("[Trading212] No instruments.json found (this is normal)", flush=True)
        
        # Parse CSV exports for additional transaction types
        if self._csv_transactions is None:
            print("\n[Trading212] === CSV EXPORTS ===", flush=True)
            csv_files = glob.glob(os.path.join(self.data_directory, "export_*.csv"))
            if csv_files:
                self._csv_transactions = self._parse_csv_files()
                csv_only = self._get_csv_only_transactions()
                print(f"[Trading212] ✓ {len(self._csv_transactions)} CSV rows, {len(csv_only)} CSV-only transactions", flush=True)
            else:
                self._csv_transactions = []
                print("[Trading212] No CSV files found (this is normal)", flush=True)
        
        # Load corporate actions (splits, mergers, etc. not in CSV)
        if self._corporate_actions is None:
            print("\n[Trading212] === CORPORATE ACTIONS ===", flush=True)
            ca_data = self._load_json_file("corporate_actions")
            if ca_data and "corporate_actions" in ca_data:
                self._corporate_actions = []
                for ca in ca_data["corporate_actions"]:
                    try:
                        self._corporate_actions.append(CorporateAction(
                            isin=ca["isin"],
                            ticker=ca["ticker"],
                            action_type=ca["type"],
                            date=datetime.datetime.strptime(ca["date"], "%Y-%m-%d").date(),
                            ratio_from=int(ca["ratio_from"]),
                            ratio_to=int(ca["ratio_to"]),
                            note=ca.get("note"),
                        ))
                    except (KeyError, ValueError) as e:
                        print(f"  [Trading212] Error parsing corporate action: {e}", flush=True)
                print(f"[Trading212] ✓ {len(self._corporate_actions)} corporate actions loaded", flush=True)
            else:
                self._corporate_actions = []
                print("[Trading212] No corporate_actions.json found (this is normal)", flush=True)
        
        print("\n" + "="*60, flush=True)
        print("[Trading212] Data load complete!", flush=True)
        print(f"  CSV transactions: {len(self._csv_transactions or [])}", flush=True)
        print(f"  Pending orders: {len(self._pending_orders or [])}", flush=True)
        print(f"  Positions: {len(self._positions or [])}", flush=True)
        print(f"  Pies mapped: {len(self._ticker_to_pie or {})}", flush=True)
        print(f"  Instruments: {len(self._instruments or {})}", flush=True)
        if self._corporate_actions:
            print(f"  Corporate actions: {len(self._corporate_actions)}", flush=True)
        print("="*60 + "\n", flush=True)
        
        # Build symbol registry after loading all data
        self._build_symbol_registry()

    def _build_symbol_registry(self) -> None:
        """Build registry mapping ISIN -> beancount symbol.
        
        ISIN is the primary key for deduplication.
        CSV ticker is preferred over positions.json ticker for the base symbol.
        If multiple different ISINs have the same base symbol, they get numbered (AAPL, AAPL.2, etc.)
        """
        # Clear existing registry
        self._symbol_registry = {}
        self._ticker_to_beancount_symbol = {}
        
        # ISIN -> (preferred_ticker, base_symbol) - CSV tickers take priority
        isin_to_info: Dict[str, Tuple[str, str]] = {}
        
        # First pass: collect from CSV (these are the preferred tickers)
        if self._csv_transactions:
            for txn in self._csv_transactions:
                if txn.isin and txn.ticker and txn.isin not in isin_to_info:
                    base_symbol = _ticker_to_base_symbol(txn.ticker)
                    isin_to_info[txn.isin] = (txn.ticker, base_symbol)
        
        # Second pass: add from positions only if ISIN not already known
        if self._positions:
            for position in self._positions:
                if position.isin and position.isin not in isin_to_info:
                    base_symbol = _ticker_to_base_symbol(position.ticker)
                    isin_to_info[position.isin] = (position.ticker, base_symbol)
        
        # Group ISINs by base symbol to detect true multi-exchange (different ISINs, same base symbol)
        base_symbol_to_isins: Dict[str, List[str]] = {}
        for isin, (ticker, base_symbol) in isin_to_info.items():
            if base_symbol not in base_symbol_to_isins:
                base_symbol_to_isins[base_symbol] = []
            base_symbol_to_isins[base_symbol].append(isin)
        
        # Assign beancount symbols - only number if truly different ISINs share base symbol
        isin_to_beancount: Dict[str, str] = {}
        for base_symbol, isins in base_symbol_to_isins.items():
            if len(isins) == 1:
                # Single ISIN - use plain base symbol
                isin = isins[0]
                # Ensure minimum 2 chars for beancount
                if len(base_symbol) < 2:
                    ticker, _ = isin_to_info[isin]
                    _, exchange_code, _ = _get_exchange_from_ticker(ticker, isin)
                    isin_to_beancount[isin] = f"{base_symbol}{exchange_code}" if exchange_code else f"{base_symbol}X"
                else:
                    isin_to_beancount[isin] = base_symbol
            else:
                # Multiple ISINs with same base symbol - first gets plain, rest get numbered
                for i, isin in enumerate(isins):
                    if i == 0 and len(base_symbol) >= 2:
                        isin_to_beancount[isin] = base_symbol
                    else:
                        isin_to_beancount[isin] = f"{base_symbol}.{i+1}" if len(base_symbol) >= 2 else f"{base_symbol}X.{i+1}"
        
        # Build ticker -> beancount symbol mapping (all tickers for same ISIN get same symbol)
        # Store ISIN -> beancount for lookups
        self._isin_to_beancount_symbol: Dict[str, str] = isin_to_beancount
        
        # Map all tickers (from both CSV and positions) to their ISIN's beancount symbol
        if self._csv_transactions:
            for txn in self._csv_transactions:
                if txn.ticker and txn.isin and txn.isin in isin_to_beancount:
                    self._ticker_to_beancount_symbol[txn.ticker] = isin_to_beancount[txn.isin]
        
        if self._positions:
            for position in self._positions:
                if position.ticker and position.isin in isin_to_beancount:
                    self._ticker_to_beancount_symbol[position.ticker] = isin_to_beancount[position.isin]
        
        # Store for logging
        self._symbol_registry = base_symbol_to_isins
        
        # Log only true multi-exchange (different ISINs, same base symbol)
        multi_exchange = {k: v for k, v in base_symbol_to_isins.items() if len(v) > 1}
        if multi_exchange:
            print(f"[Trading212] Multi-exchange symbols (different ISINs): {len(multi_exchange)}", flush=True)
            for base, isins in multi_exchange.items():
                symbols = [isin_to_beancount[isin] for isin in isins]
                print(f"  {base}: {', '.join(symbols)}", flush=True)

    def _get_beancount_symbol(self, ticker: str, isin: Optional[str] = None) -> str:
        """Get the final beancount symbol for a Trading 212 ticker.
        
        Uses the symbol registry to determine if exchange suffix is needed.
        Beancount requires minimum 2 characters for commodity names.
        """
        if ticker in self._ticker_to_beancount_symbol:
            symbol = self._ticker_to_beancount_symbol[ticker]
            # Ensure minimum 2 characters for beancount
            if len(symbol) < 2:
                _, exchange_code, _ = _get_exchange_from_ticker(ticker, isin)
                if exchange_code:
                    return f"{symbol}.{exchange_code}"
                else:
                    return f"{symbol}X"  # Pad with X if no exchange known
            return symbol
        
        # Fallback if not in registry (shouldn't happen normally)
        base_symbol = _ticker_to_base_symbol(ticker)
        
        # Ensure minimum 2 characters for beancount
        if len(base_symbol) < 2:
            return _ticker_to_symbol(ticker, include_exchange=True, isin=isin)
        
        if base_symbol in self._symbol_registry and len(self._symbol_registry[base_symbol]) > 1:
            return _ticker_to_symbol(ticker, include_exchange=True, isin=isin)
        return base_symbol

    def _get_pies_for_ticker(self, ticker: str) -> List[str]:
        """Get the pie names for a ticker, if any."""
        if self._ticker_to_pie:
            return self._ticker_to_pie.get(ticker, [])
        return []

    def _parse_csv_files(self) -> List[CsvTransaction]:
        """Parse all CSV export files from Trading 212.
        
        CSV files contain additional transaction types not in API:
        - Lending interest
        - Interest on cash
        - Dividend manufactured payment details
        
        Returns:
            List of CsvTransaction objects
        """
        if not os.path.exists(self.data_directory):
            return []
        
        transactions: Dict[str, CsvTransaction] = {}  # Dedupe by transaction_id
        csv_files = glob.glob(os.path.join(self.data_directory, "*.csv"))
        
        if not csv_files:
            return []
        
        print(f"  [Trading212] Found {len(csv_files)} CSV file(s)", flush=True)
        
        # Helper function for parsing decimals
        def safe_decimal(val: str) -> Optional[Decimal]:
            if not val or val.strip() == "":
                return None
            try:
                return D(val)
            except Exception:
                return None
        
        # Helper function for optional string
        def safe_str(val: Optional[str]) -> Optional[str]:
            if not val or val.strip() == "":
                return None
            return val.strip()
        
        for csv_path in csv_files:
            try:
                with open(csv_path, 'r', encoding='utf-8') as f:
                    reader = csv.DictReader(f)
                    for row in reader:
                        action = row.get("Action", "")
                        
                        # Parse time
                        time_str = row.get("Time", "")
                        try:
                            trans_time = datetime.datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S")
                        except ValueError:
                            continue
                        
                        txn_id = row.get("ID", "")
                        
                        # Generate synthetic ID for transactions without ID (e.g., dividends)
                        # Use short hash of action + time + ticker for a clean unique identifier
                        if not txn_id:
                            ticker = row.get("Ticker", "")
                            isin = row.get("ISIN", "")
                            raw_id = f"{action}_{time_str}_{ticker or isin}"
                            txn_id = hashlib.sha256(raw_id.encode()).hexdigest()[:12]
                        
                        # Skip if already seen (dedupe across overlapping CSV files)
                        if txn_id in transactions:
                            continue
                        
                        transactions[txn_id] = CsvTransaction(
                            action=action,
                            time=trans_time,
                            isin=safe_str(row.get("ISIN")),
                            ticker=safe_str(row.get("Ticker")),
                            name=safe_str(row.get("Name")),
                            notes=safe_str(row.get("Notes")),
                            transaction_id=txn_id,
                            num_shares=safe_decimal(row.get("No. of shares", "")),
                            price_per_share=safe_decimal(row.get("Price / share", "")),
                            price_currency=safe_str(row.get("Currency (Price / share)")),
                            exchange_rate=safe_decimal(row.get("Exchange rate", "")),
                            result=safe_decimal(row.get("Result", "")),
                            result_currency=safe_str(row.get("Currency (Result)")),
                            currency=row.get("Currency (Total)", "USD"),
                            total=safe_decimal(row.get("Total", "0")) or D(0),
                            withholding_tax=safe_decimal(row.get("Withholding tax", "")),
                            withholding_tax_currency=safe_str(row.get("Currency (Withholding tax)")),
                            charge_amount=safe_decimal(row.get("Charge amount", "")),
                            charge_currency=safe_str(row.get("Currency (Charge amount)")),
                            deposit_fee=safe_decimal(row.get("Deposit fee", "")),
                            deposit_fee_currency=safe_str(row.get("Currency (Deposit fee)")),
                            # Fee fields
                            stamp_duty=safe_decimal(row.get("Stamp duty reserve tax", "")),
                            stamp_duty_currency=safe_str(row.get("Currency (Stamp duty reserve tax)")),
                            transaction_fee=safe_decimal(row.get("Transaction fee", "")),
                            transaction_fee_currency=safe_str(row.get("Currency (Transaction fee)")),
                            finra_fee=safe_decimal(row.get("Finra fee", "")),
                            finra_fee_currency=safe_str(row.get("Currency (Finra fee)")),
                            source_file=csv_path,
                        )
            except Exception as e:
                print(f"  [Trading212] Error parsing {csv_path}: {e}", flush=True)
        
        return list(transactions.values())

    def _get_csv_only_transactions(self) -> List[CsvTransaction]:
        """Get transactions from CSV that are not in API (lending interest, interest on cash, stock distributions)."""
        if self._csv_transactions is None:
            return []
        
        # Filter for CSV-only transaction types
        csv_only_actions = {
            "Lending interest", 
            "Interest on cash",
            "Stock distribution",
            "Custom stock distribution",
        }
        return [t for t in self._csv_transactions if t.action in csv_only_actions]

    def _get_csv_enhanced_transaction_refs(self) -> set:
        """Get transaction reference IDs that have better categorization in CSV.
        
        The API may return some transactions (like interest) as generic DEPOSIT type,
        but CSV has the correct action type. We should prefer the CSV version.
        
        Returns:
            Set of transaction reference IDs that should be handled by CSV instead of API.
        """
        if self._csv_transactions is None:
            return set()
        
        # These CSV action types have better categorization than what API provides
        csv_enhanced_actions = {"Lending interest", "Interest on cash"}
        return {t.transaction_id for t in self._csv_transactions if t.action in csv_enhanced_actions}

    # Serialization helpers for caching
    def _order_to_dict(self, o: ApiOrder) -> dict:
        return {
            "order_id": o.order_id, "ticker": o.ticker, "isin": o.isin, "name": o.name,
            "side": o.side, "status": o.status, "quantity": str(o.quantity),
            "filled_quantity": str(o.filled_quantity), "filled_price": str(o.filled_price) if o.filled_price else None,
            "filled_at": o.filled_at.isoformat() if o.filled_at else None,
            "created_at": o.created_at.isoformat() if o.created_at else None,
            "currency": o.currency, "account_currency": o.account_currency,
            "fx_rate": str(o.fx_rate) if o.fx_rate else None,
            "net_value": str(o.net_value) if o.net_value else None,
            "realized_pnl": str(o.realized_pnl) if o.realized_pnl else None,
            "taxes": o.taxes,
        }

    def _dict_to_order(self, d: dict) -> ApiOrder:
        return ApiOrder(
            order_id=d["order_id"], ticker=d["ticker"], isin=d["isin"], name=d["name"],
            side=d["side"], status=d["status"], quantity=D(d["quantity"]),
            filled_quantity=D(d["filled_quantity"]),
            filled_price=D(d["filled_price"]) if d["filled_price"] else None,
            filled_at=_parse_iso_datetime(d["filled_at"]),
            created_at=_parse_iso_datetime(d["created_at"]),
            currency=d["currency"], account_currency=d["account_currency"],
            fx_rate=D(d["fx_rate"]) if d["fx_rate"] else None,
            net_value=D(d["net_value"]) if d["net_value"] else None,
            realized_pnl=D(d["realized_pnl"]) if d["realized_pnl"] else None,
            taxes=d["taxes"],
        )

    def _dividend_to_dict(self, d: ApiDividend) -> dict:
        return {
            "reference": d.reference, "ticker": d.ticker, "isin": d.isin, "name": d.name,
            "paid_on": d.paid_on.isoformat() if d.paid_on else None,
            "quantity": str(d.quantity), "amount": str(d.amount),
            "amount_per_share": str(d.amount_per_share),
            "currency": d.currency, "ticker_currency": d.ticker_currency,
            "dividend_type": d.dividend_type,
        }

    def _dict_to_dividend(self, d: dict) -> ApiDividend:
        return ApiDividend(
            reference=d["reference"], ticker=d["ticker"], isin=d["isin"], name=d["name"],
            paid_on=_parse_date(d["paid_on"]),
            quantity=D(d["quantity"]), amount=D(d["amount"]),
            amount_per_share=D(d["amount_per_share"]),
            currency=d["currency"], ticker_currency=d["ticker_currency"],
            dividend_type=d["dividend_type"],
        )

    def _transaction_to_dict(self, t: ApiTransaction) -> dict:
        return {
            "reference": t.reference, "transaction_type": t.transaction_type,
            "amount": str(t.amount), "currency": t.currency,
            "date_time": t.date_time.isoformat() if t.date_time else None,
        }

    def _dict_to_transaction(self, d: dict) -> ApiTransaction:
        return ApiTransaction(
            reference=d["reference"], transaction_type=d["transaction_type"],
            amount=D(d["amount"]), currency=d["currency"],
            date_time=_parse_iso_datetime(d["date_time"]),
        )

    def _position_to_dict(self, p: ApiPosition) -> dict:
        return {
            "ticker": p.ticker, "isin": p.isin, "name": p.name,
            "quantity": str(p.quantity), "average_price": str(p.average_price),
            "current_price": str(p.current_price), "currency": p.currency,
            "total_cost": str(p.total_cost), "current_value": str(p.current_value),
        }

    def _dict_to_position(self, d: dict) -> ApiPosition:
        return ApiPosition(
            ticker=d["ticker"], isin=d["isin"], name=d["name"],
            quantity=D(d["quantity"]), average_price=D(d["average_price"]),
            current_price=D(d["current_price"]), currency=d["currency"],
            total_cost=D(d["total_cost"]), current_value=D(d["current_value"]),
        )

    def _get_symbol_account(self, ticker: str, isin: Optional[str] = None) -> str:
        """Get the account for a specific symbol."""
        symbol = self._get_beancount_symbol(ticker, isin)
        return f"{self.investment_account}:{symbol}"

    def _make_order_transaction(self, order: ApiOrder) -> Transaction:
        """Create a beancount transaction from an order."""
        date = order.filled_at.date() if order.filled_at else order.created_at.date()
        symbol = self._get_beancount_symbol(order.ticker, order.isin)
        symbol_account = self._get_symbol_account(order.ticker, order.isin)
        
        source_desc = f"{order.side} {symbol} {order.filled_quantity} @ {order.filled_price}"
        
        # Minimal meta for all postings on Trading212 accounts (for clearing)
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{order.order_id}"}
        
        meta = {
            SOURCE_REF_KEY: f"{order.order_id}",
            SOURCE_KEY: SOURCE_ID,
            SOURCE_REF_KEY: str(order.order_id),
        }
        
        # Add all available order metadata
        meta["order_side"] = order.side
        if order.filled_quantity:
            meta["filled_quantity"] = str(order.filled_quantity)
        if order.filled_price:
            meta["filled_price"] = str(order.filled_price)
        meta["order_currency"] = order.currency
        if order.account_currency != order.currency:
            meta["account_currency"] = order.account_currency
        if order.fx_rate and order.fx_rate != D("1"):
            meta["fx_rate"] = str(order.fx_rate)
        if order.net_value is not None:
            meta["net_value"] = str(order.net_value)
        if order.realized_pnl is not None and order.realized_pnl != D("0"):
            meta["realized_pnl"] = str(order.realized_pnl)
        if order.filled_at:
            meta["filled_at"] = order.filled_at.isoformat()
        if order.created_at:
            meta["order_created_at"] = order.created_at.isoformat()
        
        # Add pie names if ticker is in any pies (comma-separated if multiple)
        pies = self._get_pies_for_ticker(order.ticker)
        if pies:
            meta["pie"] = ", ".join(pies)
        
        postings = []
        
        if order.side == "BUY":
            # Stock posting (debit)
            cost_spec = None
            if order.filled_price:
                from beancount.core.position import CostSpec
                cost_spec = CostSpec(
                    number_per=order.filled_price,
                    number_total=None,
                    currency=order.currency,
                    date=date,
                    label=None,
                    merge=None,
                )
            postings.append(Posting(
                account=symbol_account,
                units=Amount(order.filled_quantity, symbol),
                cost=cost_spec,
                price=None,
                flag=None,
                meta={**meta},
            ))
            
            # Cash posting (credit)
            if order.net_value:
                cash_amount = -order.net_value
            elif order.filled_price:
                cash_amount = -(order.filled_quantity * order.filled_price)
            else:
                cash_amount = D(0)  # Fallback for edge cases
            postings.append(Posting(
                account=self.cash_account,
                units=Amount(cash_amount, order.account_currency),
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ))
            
        elif order.side == "SELL":
            # Stock posting (credit) - selling shares
            postings.append(Posting(
                account=symbol_account,
                units=Amount(-order.filled_quantity, symbol),
                cost=None,  # Will use FIFO
                price=Amount(order.filled_price, order.currency) if order.filled_price else None,
                flag=None,
                meta={**meta},
            ))
            
            # Cash posting (debit)
            if order.net_value:
                cash_amount = order.net_value
            elif order.filled_price:
                cash_amount = order.filled_quantity * order.filled_price
            else:
                cash_amount = D(0)  # Fallback for edge cases
            postings.append(Posting(
                account=self.cash_account,
                units=Amount(cash_amount, order.account_currency),
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ))
            
            # Capital gains posting (if we have realized P&L)
            if order.realized_pnl and order.realized_pnl != 0:
                postings.append(Posting(
                    account=self.capital_gains_account,
                    units=Amount(-order.realized_pnl, order.account_currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta=source_ref_meta.copy(),
                ))
        
        narration = f"{order.side.capitalize()} {symbol}"
        
        return Transaction(
            meta={
                "filename": "<trading212>",
                "lineno": 0,
                SOURCE_REF_KEY: str(order.order_id),
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_forecast_transaction(self, order: ApiOrder) -> Transaction:
        """Create a forecast beancount transaction from a pending order.
        
        Pending orders are marked with #forecast tag and ! flag to indicate
        they are not yet executed.
        """
        # Use created_at date for pending orders, or today if not available
        date = order.created_at.date() if order.created_at else datetime.date.today()
        symbol = self._get_beancount_symbol(order.ticker, order.isin)
        symbol_account = self._get_symbol_account(order.ticker, order.isin)
        
        # For pending orders, use quantity and limit price (filled_price stores limit)
        price = order.filled_price  # This is the limit price for pending orders
        quantity = order.quantity
        
        source_desc = f"PENDING {order.side} {symbol} {quantity} @ {price or '?'}"
        
        # Simplified metadata for pending orders
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: str(order.order_id)}
        meta = {
            SOURCE_REF_KEY: str(order.order_id),
            "order_status": order.status,
            "order_desc": source_desc,
        }
        if order.created_at:
            meta["order_created_at"] = order.created_at.isoformat()
        
        postings = []
        
        if order.side == "BUY":
            # Estimate cost from limit price if available
            cost_spec = None
            if price:
                from beancount.core.position import CostSpec
                cost_spec = CostSpec(
                    number_per=price,
                    number_total=None,
                    currency=order.currency,
                    date=date,
                    label=None,
                    merge=None,
                )
            postings.append(Posting(
                account=symbol_account,
                units=Amount(quantity, symbol),
                cost=cost_spec,
                price=None,
                flag=None,
                meta={**meta},
            ))
            
            # Cash posting - estimate from net_value or calculate
            if order.net_value:
                cash_amount = -order.net_value
            elif price:
                cash_amount = -(quantity * price)
            else:
                cash_amount = D(0)
            postings.append(Posting(
                account=self.cash_account,
                units=Amount(cash_amount, order.account_currency),
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ))
            
        elif order.side == "SELL":
            postings.append(Posting(
                account=symbol_account,
                units=Amount(-quantity, symbol),
                cost=None,
                price=Amount(price, order.currency) if price else None,
                flag=None,
                meta={**meta},
            ))
            
            if order.net_value:
                cash_amount = order.net_value
            elif price:
                cash_amount = quantity * price
            else:
                cash_amount = D(0)
            postings.append(Posting(
                account=self.cash_account,
                units=Amount(cash_amount, order.account_currency),
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ))
        
        narration = f"[PENDING] {order.side.capitalize()} {symbol}"

        
        return Transaction(
            meta={
                "filename": "<trading212-forecast>",
                "lineno": 0,
                SOURCE_REF_KEY: str(order.order_id),
            },
            date=date,
            flag="!",  # Pending flag
            payee="TRADING 212",
            narration=narration,
            tags=frozenset({"forecast"}),
            links=frozenset(),
            postings=postings,
        )

    def _make_dividend_transaction(self, dividend: ApiDividend) -> Transaction:
        """Create a beancount transaction from a dividend."""
        symbol = self._get_beancount_symbol(dividend.ticker, dividend.isin)
        
        source_desc = f"Dividend {symbol} {dividend.amount} {dividend.currency}"
        
        # Minimal meta for all postings on Trading212 accounts (for clearing)
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{dividend.reference}"}
        
        meta = {
            SOURCE_REF_KEY: f"{dividend.reference}",
            SOURCE_KEY: SOURCE_ID,
            SOURCE_REF_KEY: dividend.reference,
        }
        
        # Add all available dividend metadata
        meta["dividend_type"] = dividend.dividend_type
        if dividend.quantity:
            meta["quantity"] = str(dividend.quantity)
        if dividend.amount_per_share:
            meta["amount_per_share"] = str(dividend.amount_per_share)
        meta["ticker_currency"] = dividend.ticker_currency
        if dividend.ticker_currency != dividend.currency:
            meta["account_currency"] = dividend.currency
        
        # Add pie names if ticker is in any pies (comma-separated if multiple)
        pies = self._get_pies_for_ticker(dividend.ticker)
        if pies:
            meta["pie"] = ", ".join(pies)
        
        postings = [
            # Cash received
            Posting(
                account=self.cash_account,
                units=Amount(dividend.amount, dividend.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**meta},
            ),
            # Income
            Posting(
                account=f"{self.dividend_income_account}:{symbol}",
                units=Amount(-dividend.amount, dividend.currency),
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ),
        ]
        
        narration = f"Dividend - {symbol}"
        
        return Transaction(
            meta={
                "filename": "<trading212>",
                "lineno": 0,
                SOURCE_REF_KEY: dividend.reference,
            },
            date=dividend.paid_on,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_cash_transaction(self, txn: ApiTransaction) -> Transaction:
        """Create a beancount transaction from a cash transaction."""
        date = txn.date_time.date()
        
        source_desc = f"{txn.transaction_type} {txn.amount} {txn.currency}"
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            SOURCE_REF_KEY: txn.reference,
        }
        
        # Add all available transaction metadata
        meta["transaction_type"] = txn.transaction_type
        if txn.date_time:
            meta["transaction_time"] = txn.date_time.isoformat()
        
        postings = []
        needs_fixme = False
        
        if txn.transaction_type == "DEPOSIT":
            postings = [
                Posting(
                    account=self.cash_account,
                    units=Amount(txn.amount, txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta={**meta},
                ),
                Posting(
                    account=self.transfer_account,
                    units=Amount(-txn.amount, txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta=None,
                ),
            ]
            narration = "Deposit"
            
        elif txn.transaction_type == "WITHDRAW":
            postings = [
                Posting(
                    account=self.cash_account,
                    units=Amount(-abs(txn.amount), txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta={**meta},
                ),
                Posting(
                    account=self.transfer_account,
                    units=Amount(abs(txn.amount), txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta=None,
                ),
            ]
            narration = "Withdrawal"
            
        elif txn.transaction_type == "FEE":
            postings = [
                Posting(
                    account=self.cash_account,
                    units=Amount(-abs(txn.amount), txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta={**meta},
                ),
                Posting(
                    account=self.fees_account,
                    units=Amount(abs(txn.amount), txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta=None,
                ),
            ]
            narration = "Fee"
            
        else:  # TRANSFER or other - needs manual review
            postings = [
                Posting(
                    account=self.cash_account,
                    units=Amount(txn.amount, txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta={**meta},
                ),
                Posting(
                    account=FIXME_ACCOUNT,
                    units=Amount(-txn.amount, txn.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta=None,
                ),
            ]
            narration = f"Transfer - {txn.transaction_type}"
            needs_fixme = True
        
        tags = {"imported"}
        if needs_fixme:
            tags.add("fixme")
        
        return Transaction(
            meta={
                "filename": "<trading212>",
                "lineno": 0,
                SOURCE_REF_KEY: txn.reference,
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(tags),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_income_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction from a CSV income entry (lending/interest)."""
        date = csv_txn.time.date()
        
        source_desc = f"{csv_txn.action} {csv_txn.total} {csv_txn.currency}"
        
        # Use same metadata key as API transactions for consistent matching
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        # Add all available CSV metadata
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        if csv_txn.num_shares is not None:
            meta["num_shares"] = str(csv_txn.num_shares)
        if csv_txn.price_per_share is not None:
            meta["price_per_share"] = str(csv_txn.price_per_share)
        if csv_txn.price_currency:
            meta["price_currency"] = csv_txn.price_currency
        if csv_txn.exchange_rate is not None and csv_txn.exchange_rate != D("1"):
            meta["exchange_rate"] = str(csv_txn.exchange_rate)
        if csv_txn.result is not None:
            meta["result"] = str(csv_txn.result)
        if csv_txn.result_currency:
            meta["result_currency"] = csv_txn.result_currency
        if csv_txn.withholding_tax is not None:
            meta["withholding_tax"] = str(csv_txn.withholding_tax)
        if csv_txn.withholding_tax_currency:
            meta["withholding_tax_currency"] = csv_txn.withholding_tax_currency
        if csv_txn.charge_amount is not None:
            meta["charge_amount"] = str(csv_txn.charge_amount)
        if csv_txn.charge_currency:
            meta["charge_currency"] = csv_txn.charge_currency
        if csv_txn.deposit_fee is not None:
            meta["deposit_fee"] = str(csv_txn.deposit_fee)
        if csv_txn.deposit_fee_currency:
            meta["deposit_fee_currency"] = csv_txn.deposit_fee_currency
        
        # Determine the income account based on action
        if csv_txn.action == "Lending interest":
            income_account = self.lending_income_account
            narration = "Share Lending Interest"
        elif csv_txn.action == "Interest on cash":
            income_account = self.interest_income_account
            narration = "Interest on Cash"
        else:
            income_account = "Income:Other"
            narration = csv_txn.action
        
        
        postings = [
            # Cash received
            Posting(
                account=self.cash_account,
                units=Amount(csv_txn.total, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**meta},
            ),
            # Income
            Posting(
                account=income_account,
                units=Amount(-csv_txn.total, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{csv_txn.transaction_id}"},
            ),
        ]
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_fee_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction from a CSV fee entry (ADR Fee, etc.)."""
        date = csv_txn.time.date()
        
        source_desc = f"{csv_txn.action} {csv_txn.total} {csv_txn.currency}"
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        if csv_txn.isin:
            meta[ISIN_KEY] = csv_txn.isin
        if csv_txn.name:
            meta[INSTRUMENT_NAME_KEY] = csv_txn.name
        
        # Fees should come out of cash (negative total) and go to fees expense
        # The CSV total is typically negative for fees
        fee_amount = abs(csv_txn.total)
        
        
        postings = [
            # Cash debited
            Posting(
                account=self.cash_account,
                units=Amount(-fee_amount, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**meta},
            ),
            # Fee expense
            Posting(
                account=self.fees_account,
                units=Amount(fee_amount, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta=None,
            ),
        ]
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=csv_txn.action,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_stock_distribution(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction for a stock distribution (corporate action).
        
        Stock distributions are corporate actions where shares are added to the account
        at zero cost (e.g., stock splits, spin-offs, or bonus share distributions).
        """
        date = csv_txn.time.date()
        
        # Get the symbol for this stock
        symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
        symbol_account = f"{self.investment_account}:{symbol}"
        
        source_desc = f"{csv_txn.action}: {csv_txn.num_shares} {symbol}"
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        # Add all available CSV metadata
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        
        # Import CostSpec for zero-cost shares
        from beancount.core.position import CostSpec
        
        
        # Stock distribution: receive shares at zero cost
        postings = [
            # Shares received
            Posting(
                account=symbol_account,
                units=Amount(csv_txn.num_shares, symbol),
                cost=CostSpec(
                    number_per=D("0"),  # Zero cost basis
                    number_total=None,
                    currency=csv_txn.currency,
                    date=None,
                    label=None,
                    merge=None,
                ),
                price=None,
                flag=None,
                meta={**meta},
            ),
            # Offset from income (value received for free)
            Posting(
                account=f"{self.dividend_income_account}:{symbol}",
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta={SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{csv_txn.transaction_id}"},
            ),
        ]
        
        action_type = "Custom Stock Distribution" if "Custom" in csv_txn.action else "Stock Distribution"
        narration = f"{action_type} - {symbol}"
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_order_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction from a CSV order (buy/sell).
        
        Handles: Market buy, Market sell, Limit buy, Limit sell, 
                 Stop buy, Stop sell, Stop limit buy, Stop limit sell
        """
        from beancount.core.position import CostSpec
        
        date = csv_txn.time.date()
        
        # Determine if buy or sell
        is_buy = "buy" in csv_txn.action.lower()
        is_sell = "sell" in csv_txn.action.lower()
        
        # Get the symbol for this stock
        symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
        symbol_account = f"{self.investment_account}:{symbol}"
        
        # Determine order type from action
        order_type = csv_txn.action.replace(" buy", "").replace(" sell", "")
        
        source_desc = f"{csv_txn.action}: {csv_txn.num_shares} {symbol} @ {csv_txn.price_per_share}"
        
        # Minimal meta for all postings on Trading212 accounts (for clearing)
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{csv_txn.transaction_id}"}
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        # Add CSV metadata
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        if csv_txn.result is not None:
            meta["realized_pnl"] = str(csv_txn.result)
        
        # Add pie info if available
        pies = self._get_pies_for_ticker(csv_txn.ticker)
        if pies:
            meta["pie"] = ", ".join(pies)
        
        # Add original price data for reference (especially useful for cross-currency transactions)
        if csv_txn.price_per_share:
            meta["price_per_share"] = str(csv_txn.price_per_share)
        if csv_txn.price_currency:
            meta["price_currency"] = csv_txn.price_currency
        if csv_txn.exchange_rate and csv_txn.exchange_rate != D("1"):
            meta["exchange_rate"] = str(csv_txn.exchange_rate)
        
        postings = []
        
        if is_buy:
            # Buy: increase shares, decrease cash
            quantity = csv_txn.num_shares
            cash_amount = -abs(csv_txn.total)  # Negative for outflow
            
            # Calculate per-share cost in account currency to ensure transactions balance.
            # This handles both rounding issues and cross-currency transactions (e.g., GBX stock with USD cash).
            # CSV total includes fees, so subtract them to get the actual stock cost.
            total_fees = D("0")
            if csv_txn.stamp_duty:
                total_fees += abs(csv_txn.stamp_duty)
            if csv_txn.transaction_fee:
                total_fees += abs(csv_txn.transaction_fee)
            if csv_txn.finra_fee:
                total_fees += abs(csv_txn.finra_fee)
            
            stock_cost = abs(csv_txn.total) - total_fees
            cost_per_share = stock_cost / csv_txn.num_shares
            cost_spec = CostSpec(
                number_per=cost_per_share,  # Per-share cost in account currency (excluding fees)
                number_total=None,
                currency=csv_txn.currency,  # Always use account/cash currency (e.g., USD)
                date=date,  # Include date for unique lot identification
                label=None,
                merge=None,
            )
            
            postings.append(Posting(
                account=symbol_account,
                units=Amount(quantity, symbol),
                cost=cost_spec,
                price=None,
                flag=None,
                meta={**meta},
            ))
            
        elif is_sell:
            # Sell: decrease shares, increase cash, P&L to capital gains
            quantity = -abs(csv_txn.num_shares)  # Negative for sale
            cash_amount = abs(csv_txn.total)  # Positive for inflow
            
            # For sells, use empty CostSpec {} to let FIFO matching work
            postings.append(Posting(
                account=symbol_account,
                units=Amount(quantity, symbol),
                cost=CostSpec(
                    number_per=None,  # No price - FIFO will match
                    number_total=None,
                    currency=None,
                    date=None,  # No date - FIFO will match
                    label=None,
                    merge=None,
                ),
                price=None,
                flag=None,
                meta={**meta},
            ))
        
        
        # Cash posting
        postings.append(Posting(
            account=self.cash_account,
            units=Amount(D(str(cash_amount)), csv_txn.currency),
            cost=None,
            price=None,
            flag=None,
            meta=source_ref_meta.copy(),
        ))
        
        # P&L posting for sales
        if is_sell and csv_txn.result is not None:
            postings.append(Posting(
                account=self.capital_gains_account,
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ))
        
        # Fee postings
        if csv_txn.stamp_duty and csv_txn.stamp_duty != D("0"):
            postings.append(Posting(
                account=self.fees_account,
                units=Amount(abs(csv_txn.stamp_duty), csv_txn.stamp_duty_currency or csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**source_ref_meta, "fee_type": "stamp_duty"},
            ))
        
        if csv_txn.transaction_fee and csv_txn.transaction_fee != D("0"):
            postings.append(Posting(
                account=self.fees_account,
                units=Amount(abs(csv_txn.transaction_fee), csv_txn.transaction_fee_currency or csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**source_ref_meta, "fee_type": "transaction_fee"},
            ))
        
        if csv_txn.finra_fee and csv_txn.finra_fee != D("0"):
            postings.append(Posting(
                account=self.fees_account,
                units=Amount(abs(csv_txn.finra_fee), csv_txn.finra_fee_currency or csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**source_ref_meta, "fee_type": "finra_fee"},
            ))
        
        side = "Buy" if is_buy else "Sell"
        narration = f"{order_type} {side} - {symbol}"
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_dividend_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction from a CSV dividend entry.
        
        Handles all dividend types:
        - Dividend (Dividend)
        - Dividend (Ordinary)
        - Dividend (Bonus)
        - Dividend (Dividend manufactured payment)
        - etc.
        """
        date = csv_txn.time.date()
        
        # Get the symbol for this stock
        symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
        income_account = f"{self.dividend_income_account}:{symbol}"
        
        # Extract dividend type from action (e.g., "Dividend (Ordinary)" -> "Ordinary")
        div_type = "Dividend"
        if "(" in csv_txn.action and ")" in csv_txn.action:
            div_type = csv_txn.action.split("(")[1].rstrip(")")
        
        source_desc = f"Dividend ({div_type}): {symbol}"
        
        # Minimal meta for all postings on Trading212 accounts (for clearing)
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{csv_txn.transaction_id}"}
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        # Add CSV metadata
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        meta["dividend_type"] = div_type
        if csv_txn.num_shares:
            meta["quantity"] = str(csv_txn.num_shares)
        
        # Add pie info if available
        pies = self._get_pies_for_ticker(csv_txn.ticker)
        if pies:
            meta["pie"] = ", ".join(pies)
        
        postings = []
        
        # Cash received
        gross_amount = csv_txn.total
        if csv_txn.withholding_tax:
            gross_amount = gross_amount + abs(csv_txn.withholding_tax)
        
        postings.append(Posting(
            account=self.cash_account,
            units=Amount(csv_txn.total, csv_txn.currency),
            cost=None,
            price=None,
            flag=None,
            meta={**meta},
        ))
        
        # Clearing metadata
        
        # Withholding tax if any
        if csv_txn.withholding_tax and csv_txn.withholding_tax != 0:
            postings.append(Posting(
                account=self.fees_account,
                units=Amount(abs(csv_txn.withholding_tax), csv_txn.withholding_tax_currency or csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**source_ref_meta, "tax_type": "withholding_tax"},
            ))
        
        # Income source
        postings.append(Posting(
            account=income_account,
            units=None,  # Auto-balance
            cost=None,
            price=None,
            flag=None,
            meta=source_ref_meta.copy(),
        ))
        
        narration = f"Dividend ({div_type}) - {symbol}"
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_deposit_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction from a CSV deposit entry."""
        date = csv_txn.time.date()
        
        source_desc = f"Deposit: {csv_txn.total} {csv_txn.currency}"
        
        # Minimal meta for all postings on Trading212 accounts (for clearing)
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{csv_txn.transaction_id}"}
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        
        # Clearing metadata
        
        postings = [
            Posting(
                account=self.cash_account,
                units=Amount(csv_txn.total, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**meta},
            ),
            Posting(
                account=self.transfer_account,
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta=None,
            ),
        ]
        
        # Deposit fee if any
        if csv_txn.deposit_fee and csv_txn.deposit_fee != 0:
            postings.insert(1, Posting(
                account=self.fees_account,
                units=Amount(abs(csv_txn.deposit_fee), csv_txn.deposit_fee_currency or csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**source_ref_meta, "fee_type": "deposit_fee"},
            ))
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration="Deposit",
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_withdrawal_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction from a CSV withdrawal entry."""
        date = csv_txn.time.date()
        
        source_desc = f"Withdrawal: {csv_txn.total} {csv_txn.currency}"
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        
        # Total should be negative for withdrawal
        amount = -abs(csv_txn.total) if csv_txn.total > 0 else csv_txn.total
        
        # Clearing metadata
        
        postings = [
            Posting(
                account=self.cash_account,
                units=Amount(amount, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**meta},
            ),
            Posting(
                account=self.transfer_account,
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta=None,
            ),
        ]
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration="Withdrawal",
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_corporate_action_removal(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a transaction for corporate action stock removal (sell @ $0).
        
        This handles cases where shares are converted to a new ticker (e.g., HCMC.CNT -> HCWC).
        The old shares are removed at zero cost with the loss going to Equity:CorporateAction.
        """
        from beancount.core.position import CostSpec
        
        date = csv_txn.time.date()
        
        symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
        symbol_account = f"{self.investment_account}:{symbol}"
        
        source_desc = f"Corp Action Removal: {csv_txn.num_shares} {symbol}"
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}",
            SOURCE_KEY: SOURCE_ID,
            SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
        }
        
        meta[TRANSACTION_TYPE_KEY] = "Corporate Action - Stock Removal"
        meta["original_action"] = csv_txn.action
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        
        # Remove the shares at zero cost
        quantity = -abs(csv_txn.num_shares)
        
        # Clearing metadata
        
        postings = [
            Posting(
                account=symbol_account,
                units=Amount(quantity, symbol),
                cost=CostSpec(
                    number_per=None,  # Take from lot at any cost
                    number_total=None,
                    currency=None,
                    date=None,
                    label=None,
                    merge=None,
                ),
                price=None,
                flag=None,
                meta={**meta},
            ),
            # Balance to equity account (the cost basis of these shares is a loss)
            Posting(
                account="Equity:CorporateAction",
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta=None,
            ),
        ]
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=f"Corporate Action - {symbol} Removal",
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_stock_split_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction for stock split open/close."""
        date = csv_txn.time.date()
        
        symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
        symbol_account = f"{self.investment_account}:{symbol}"
        
        is_open = "open" in csv_txn.action.lower()
        
        source_desc = f"{csv_txn.action}: {csv_txn.num_shares} {symbol}"
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        
        from beancount.core.position import CostSpec
        
        # For stock split, shares change but value stays same
        # Open = remove old shares, Close = add new shares
        quantity = csv_txn.num_shares if is_open else -abs(csv_txn.num_shares)
        
        # Clearing metadata
        
        postings = [
            Posting(
                account=symbol_account,
                units=Amount(quantity, symbol),
                cost=CostSpec(
                    number_per=None,
                    number_total=None,
                    currency=csv_txn.currency,
                    date=None,
                    label=None,
                    merge=None,
                ),
                price=None,
                flag=None,
                meta={**meta},
            ),
            # Balance against equity for stock split adjustments
            Posting(
                account="Equity:StockSplit",
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta=None,
            ),
        ]
        
        narration = f"Stock Split {'Open' if is_open else 'Close'} - {symbol}"
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=narration,
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )

    def _make_csv_adjustment_transaction(self, csv_txn: CsvTransaction) -> Transaction:
        """Create a beancount transaction for result adjustments."""
        date = csv_txn.time.date()
        
        source_desc = f"{csv_txn.action}: {csv_txn.total} {csv_txn.currency}"
        
        # Minimal meta for all postings on Trading212 accounts (for clearing)
        source_ref_meta = {SOURCE_KEY: SOURCE_ID, SOURCE_REF_KEY: f"{csv_txn.transaction_id}"}
        
        meta = {
            SOURCE_REF_KEY: f"{csv_txn.transaction_id}", SOURCE_KEY: SOURCE_ID, SOURCE_DOC_KEY: os.path.basename(csv_txn.source_file) if csv_txn.source_file else None,
            
        }
        
        meta[TRANSACTION_TYPE_KEY] = csv_txn.action
        if csv_txn.ticker:
            meta[TICKER_KEY] = csv_txn.ticker
        meta["transaction_time"] = csv_txn.time.isoformat()
        if csv_txn.notes:
            meta["notes"] = csv_txn.notes
        
        # Clearing metadata
        
        postings = [
            Posting(
                account=self.cash_account,
                units=Amount(csv_txn.total, csv_txn.currency),
                cost=None,
                price=None,
                flag=None,
                meta={**meta},
            ),
            Posting(
                account=self.capital_gains_account,
                units=None,  # Auto-balance
                cost=None,
                price=None,
                flag=None,
                meta=source_ref_meta.copy(),
            ),
        ]
        
        return Transaction(
            meta={
                "filename": "<trading212-csv>",
                "lineno": 0,
                
            },
            date=date,
            flag="*",
            payee="TRADING 212",
            narration=f"Result Adjustment",
            tags=frozenset(),
            links=frozenset(),
            postings=postings,
        )


    def _make_balance_assertion(self, position: ApiPosition, date: datetime.date) -> Balance:
        """Create a balance assertion for a position."""
        symbol = self._get_beancount_symbol(position.ticker, position.isin)
        symbol_account = f"{self.investment_account}:{symbol}"
        
        return Balance(
            meta={
                "filename": "<trading212>",
                "lineno": 0,
            },
            date=date,
            account=symbol_account,
            amount=Amount(position.quantity, symbol),
            tolerance=None,
            diff_amount=None,
        )

    def _make_cash_balance_assertion(self, summary: ApiAccountSummary, date: datetime.date) -> Balance:
        """Create a balance assertion for cash."""
        total_cash = summary.cash_available + summary.cash_in_pies + summary.cash_reserved
        
        return Balance(
            meta={
                "filename": "<trading212>",
                "lineno": 0,
            },
            date=date,
            account=self.cash_account,
            amount=Amount(total_cash, summary.currency),
            tolerance=None,
            diff_amount=None,
        )

    def _make_corporate_action_entry(self, ca: CorporateAction) -> Custom:
        """Create a custom autobean.stock_split directive for a corporate action.
        
        Format: 2024-06-10 custom "autobean.stock_split" 10 NVDA
        
        For forward splits (10:1), ratio = 10 (10 new shares per 1 old)
        For reverse splits (1:30), ratio = 1/30 ≈ 0.0333... (0.033 new shares per 1 old)
        """
        symbol = self._get_beancount_symbol(ca.ticker, ca.isin)
        
        # Calculate ratio: new shares per old share
        if ca.action_type == "split":
            # Forward split: e.g., 10:1 means 10 new shares per 1 old
            ratio = D(str(ca.ratio_from)) / D(str(ca.ratio_to))
        elif ca.action_type == "reverse_split":
            # Reverse split: e.g., 1:30 means 1 new share per 30 old
            ratio = D(str(ca.ratio_to)) / D(str(ca.ratio_from))
        else:
            ratio = D("1")
        
        # Create unique ref for matching
        ca_ref = f"{ca.isin}:{ca.date}:{ca.action_type}"
        
        meta = {
            "filename": "<trading212>",
            "lineno": 0,
            "corporate_action_ref": ca_ref,
        }
        if ca.note:
            meta["note"] = ca.note
        
        # Custom directive format: custom "autobean.stock_split" ratio COMMODITY
        # Values must be (value, dtype) tuples for beancount printer
        values = [
            (ratio, Decimal),  # Decimal - ratio of new shares to old
            (symbol, str),  # String - commodity symbol
        ]
        
        return Custom(
            meta=meta,
            date=ca.date,
            type="autobean.stock_split",
            values=values,
        )

    def is_posting_cleared(self, posting: Posting) -> bool:
        """Check if a posting is cleared.

        A posting is cleared if it has source="trading212" and a source_ref.

        Args:
            posting: The posting to check.

        Returns:
            True if the posting is cleared.
        """
        if posting.meta is None:
            return False
        source = posting.meta.get(SOURCE_KEY)
        source_ref = posting.meta.get(SOURCE_REF_KEY)
        if source == SOURCE_ID and source_ref:
            return True
        return False

    def get_example_key_value_pairs(
        self, transaction: Transaction, posting: Posting
    ) -> Dict[str, Union[str, Sequence[str]]]:
        result = super().get_example_key_value_pairs(transaction, posting)
        if posting.meta:
            for key in (SOURCE_REF_KEY, SOURCE_REF_KEY, SOURCE_REF_KEY):
                value = posting.meta.get(key)
                if value:
                    result[key] = value
        return result

    def prepare(self, journal: JournalEditor, results: SourceResults) -> None:
        # Fetch all data from API
        try:
            self._load_all_data()
        except Trading212DataError as e:
            results.add_error(f"Failed to fetch data from Trading 212 API: {e}")
            return
        
        # Build set of accounts we're authoritative for
        account_set = {self.cash_account}
        
        # Collect all unique references from journal to match against
        matched_order_ids: Dict[str, List[Tuple[Transaction, Posting]]] = {}
        matched_dividend_refs: Dict[str, List[Tuple[Transaction, Posting]]] = {}
        matched_transaction_refs: Dict[str, List[Tuple[Transaction, Posting]]] = {}
        
        for entry in journal.all_entries:
            if not isinstance(entry, Transaction):
                continue
            for posting in entry.postings:
                if posting.meta is None:
                    continue
                
                # Primary matching using source_ref key (format: "trading212:ID")
                source_ref = posting.meta.get(SOURCE_REF_KEY)
                if source_ref and source_ref.startswith("trading212:"):
                    txn_id = source_ref[len("trading212:"):]
                    matched_transaction_refs.setdefault(txn_id, []).append((entry, posting))
                
                # Legacy matching for backward compatibility
                order_id = posting.meta.get(SOURCE_REF_KEY)
                if order_id and order_id != source_ref:  # Avoid duplicate if same as source_ref
                    matched_order_ids.setdefault(order_id, []).append((entry, posting))
                
                div_ref = posting.meta.get(SOURCE_REF_KEY)
                if div_ref:
                    matched_dividend_refs.setdefault(div_ref, []).append((entry, posting))
        
        # =====================================================================
        # CSV-FIRST PROCESSING
        # Process all transactions from CSV as the primary data source.
        # JSON data is used only for supplemental metadata (pies, instruments).
        # =====================================================================
        
        if self._csv_transactions:
            # Define action handlers for CSV transactions
            order_actions = {
                "Market buy", "Market sell",
                "Limit buy", "Limit sell",
                "Stop buy", "Stop sell",
                "Stop limit buy", "Stop limit sell",
            }
            dividend_actions = {a for a in set(t.action for t in self._csv_transactions) if a.startswith("Dividend")}
            stock_distribution_actions = {"Stock distribution", "Custom stock distribution"}
            stock_split_actions = {"Stock split open", "Stock split close"}
            
            for csv_txn in self._csv_transactions:
                # Skip if already matched using the unified trading212_transaction_ref key
                if csv_txn.transaction_id in matched_transaction_refs:
                    continue
                
                action = csv_txn.action
                txn = None
                txn_type = "trading212_csv"
                
                # Detect corporate action sell (sell @ $0 with no proceeds - stock conversion)
                # Note: price can be 0E-10 in CSV, so use < comparison with small tolerance
                is_corp_action_sell = (
                    action in order_actions and 
                    "sell" in action.lower() and
                    csv_txn.price_per_share is not None and
                    abs(csv_txn.price_per_share) < D("0.0001") and
                    abs(csv_txn.total) < D("0.01")
                )
                
                # Route to appropriate handler based on action
                if is_corp_action_sell:
                    # This is a corporate action - shares removed at zero cost (stock conversion)
                    txn = self._make_csv_corporate_action_removal(csv_txn)
                    txn_type = "trading212_corp_action_sell"
                    symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
                    symbol_account = f"{self.investment_account}:{symbol}"
                    account_set.add(symbol_account)
                    
                elif action in order_actions:
                    txn = self._make_csv_order_transaction(csv_txn)
                    txn_type = "trading212_order"
                    # Add symbol account
                    symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
                    symbol_account = f"{self.investment_account}:{symbol}"
                    account_set.add(symbol_account)
                    
                elif action in dividend_actions:
                    txn = self._make_csv_dividend_transaction(csv_txn)
                    txn_type = "trading212_dividend"
                    symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
                    account_set.add(f"{self.dividend_income_account}:{symbol}")
                    
                elif action == "Deposit":
                    txn = self._make_csv_deposit_transaction(csv_txn)
                    txn_type = "trading212_deposit"
                    
                elif action == "Withdrawal":
                    txn = self._make_csv_withdrawal_transaction(csv_txn)
                    txn_type = "trading212_withdrawal"
                    
                elif action in {"Lending interest", "Interest on cash"}:
                    txn = self._make_csv_income_transaction(csv_txn)
                    txn_type = "trading212_income"
                    
                elif action in stock_distribution_actions:
                    txn = self._make_csv_stock_distribution(csv_txn)
                    txn_type = "trading212_stock_distribution"
                    symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
                    symbol_account = f"{self.investment_account}:{symbol}"
                    account_set.add(symbol_account)
                    
                elif action in stock_split_actions:
                    txn = self._make_csv_stock_split_transaction(csv_txn)
                    txn_type = "trading212_stock_split"
                    symbol = self._get_beancount_symbol(csv_txn.ticker, csv_txn.isin)
                    symbol_account = f"{self.investment_account}:{symbol}"
                    account_set.add(symbol_account)
                    
                elif action == "Result adjustment":
                    txn = self._make_csv_adjustment_transaction(csv_txn)
                    txn_type = "trading212_adjustment"
                    
                elif action == "ADR Fee":
                    txn = self._make_csv_fee_transaction(csv_txn)
                    txn_type = "trading212_fee"
                    
                else:
                    # Unknown action type - log warning and skip
                    print(f"[Trading212] Warning: Unknown CSV action type: {action}", flush=True)
                    continue
                
                if txn:
                    # Validate that all postings have accounts (debug None account issue)
                    has_none_account = any(p.account is None for p in txn.postings)
                    if has_none_account:
                        print(f"[Trading212] ERROR: Transaction has None account!", flush=True)
                        print(f"  Action: {action}", flush=True)
                        print(f"  Transaction ID: {csv_txn.transaction_id}", flush=True)
                        print(f"  Postings:", flush=True)
                        for i, p in enumerate(txn.postings):
                            print(f"    [{i}] account={p.account}, units={p.units}", flush=True)
                        continue  # Skip this transaction
                    
                    results.add_pending_entry(ImportResult(
                        date=txn.date,
                        entries=[txn],
                        info={
                            "type": txn_type,
                            "action": action,
                            "transaction_ref": csv_txn.transaction_id,
                        },
                    ))
        
        # =====================================================================
        # PENDING ORDERS (from JSON - still useful for forecasting)
        # =====================================================================
        
        # Process pending orders as forecasts (these are still useful from JSON)
        if self._pending_orders:
            for order in self._pending_orders:
                order_id = str(order.order_id)
                
                if order_id in matched_order_ids:
                    continue
                
                txn = self._make_forecast_transaction(order)
                results.add_pending_entry(ImportResult(
                    date=txn.date,
                    entries=[txn],
                    info={
                        "type": "trading212_forecast",
                        "order_id": order_id,
                        "status": order.status,
                    },
                ))
        
        # Generate balance assertions for current positions (use fetched_at date from JSON)
        positions_date = (self._positions_fetched_at.date() if self._positions_fetched_at else datetime.date.today())
        
        for position in self._positions:
            symbol_account = self._get_symbol_account(position.ticker, position.isin)
            account_set.add(symbol_account)
            
            balance = self._make_balance_assertion(position, positions_date)
            results.add_pending_entry(ImportResult(
                date=positions_date,
                entries=[balance],
                info={
                    "type": "trading212_balance",
                    "ticker": position.ticker,
                },
            ))
        
        # Generate Price directives from current_price in positions
        # If fetched between 00:00-05:00, use previous day (market was closed)
        price_date = positions_date
        if self._positions_fetched_at:
            hour = self._positions_fetched_at.hour
            if 0 <= hour < 5:
                price_date = positions_date - datetime.timedelta(days=1)
        
        for position in self._positions:
            if position.current_price and position.current_price > 0:
                symbol = self._get_beancount_symbol(position.ticker, position.isin)
                price_directive = Price(
                    meta={"filename": "<trading212-positions>", "lineno": 0},
                    date=price_date,
                    currency=symbol,
                    amount=Amount(position.current_price, position.currency),
                )
                results.add_pending_entry(ImportResult(
                    date=price_date,
                    entries=[price_directive],
                    info={
                        "type": "trading212_price",
                        "ticker": position.ticker,
                    },
                ))
        
        # Generate cash balance assertion (use fetched_at date from account_summary)
        if self._account_summary:
            cash_date = self._account_summary_fetched_at or datetime.date.today()
            cash_balance = self._make_cash_balance_assertion(self._account_summary, cash_date)
            results.add_pending_entry(ImportResult(
                date=cash_date,
                entries=[cash_balance],
                info={
                    "type": "trading212_cash_balance",
                },
            ))
        
        # Register all accounts
        results.add_accounts(account_set)
        
        # Add commodity directives as pending entries (to be confirmed in UI)
        self._add_commodity_entries(journal, results)
        
        # =====================================================================
        # CORPORATE ACTIONS (from JSON - generate custom stock_split directives)
        # =====================================================================
        
        if self._corporate_actions:
            # Collect existing corporate action refs from journal
            matched_ca_refs = set()
            for entry in journal.all_entries:
                if isinstance(entry, Custom) and entry.type == "autobean.stock_split":
                    # Extract ref from meta if present
                    if entry.meta and "corporate_action_ref" in entry.meta:
                        matched_ca_refs.add(entry.meta["corporate_action_ref"])
            
            for ca in self._corporate_actions:
                # Create unique ref for this corporate action
                ca_ref = f"{ca.isin}:{ca.date}:{ca.action_type}"
                
                if ca_ref in matched_ca_refs:
                    continue
                
                # Only generate for splits (forward and reverse)
                if ca.action_type in ("split", "reverse_split"):
                    custom_entry = self._make_corporate_action_entry(ca)
                    results.add_pending_entry(ImportResult(
                        date=ca.date,
                        entries=[custom_entry],
                        info={
                            "type": "trading212_corporate_action",
                            "action_type": ca.action_type,
                            "ticker": ca.ticker,
                            "isin": ca.isin,
                        },
                    ))
        
        # =====================================================================
        # DOCUMENT DIRECTIVES (for CSV source files)
        # =====================================================================
        
        # Generate Document directives for each CSV file
        csv_files_with_dates = {}  # filename -> max_date
        for txn in self._csv_transactions or []:
            if txn.source_file:
                txn_date = txn.time.date()
                if txn.source_file not in csv_files_with_dates:
                    csv_files_with_dates[txn.source_file] = txn_date
                else:
                    csv_files_with_dates[txn.source_file] = max(
                        csv_files_with_dates[txn.source_file], txn_date
                    )
        
        for csv_path, max_date in csv_files_with_dates.items():
            doc_basename = os.path.basename(csv_path)
            results.add_pending_entry(ImportResult(
                date=max_date,
                entries=[
                    Document(
                        meta=None,
                        date=max_date,
                        account=self.cash_account,
                        filename=csv_path,  # Absolute path
                        tags=EMPTY_SET,
                        links=EMPTY_SET,
                    )
                ],
                info=dict(
                    type='text/csv',
                    filename=doc_basename,
                ),
            ))
        
        # Generate control report to check for discrepancies
        # Report is saved to data_directory
        self._generate_control_report()

    def _generate_control_report(self) -> None:
        """Generate a control report comparing calculated vs actual balances.
        
        This report helps identify data gaps, missing transactions, or discrepancies
        between the calculated values from transaction history and the actual
        positions/balances reported by the API.
        """
        if not self.data_directory:
            return
        
        print("\n[Trading212] Generating control report...", flush=True)
        
        report = {
            "generated_at": datetime.datetime.now().isoformat(),
            "summary": {},
            "cash_flow": {},
            "positions": {},
            "discrepancies": [],
            "warnings": [],
        }
        
        # =====================================================================
        # Section 1: Transaction Summary (CSV-first)
        # =====================================================================
        
        # Count CSV transactions by action type
        csv_action_counts = {}
        if self._csv_transactions:
            for t in self._csv_transactions:
                csv_action_counts[t.action] = csv_action_counts.get(t.action, 0) + 1
        
        # Categorize CSV transactions
        csv_orders = [t for t in (self._csv_transactions or []) 
                      if any(x in t.action for x in ["buy", "sell"]) 
                      and "Dividend" not in t.action]
        csv_buy_orders = [t for t in csv_orders if "buy" in t.action.lower()]
        csv_sell_orders = [t for t in csv_orders if "sell" in t.action.lower()]
        csv_dividends = [t for t in (self._csv_transactions or []) if t.action.startswith("Dividend")]
        csv_deposits = [t for t in (self._csv_transactions or []) if t.action == "Deposit"]
        csv_withdrawals = [t for t in (self._csv_transactions or []) if t.action == "Withdrawal"]
        csv_lending_interest = [t for t in (self._csv_transactions or []) if t.action == "Lending interest"]
        csv_cash_interest = [t for t in (self._csv_transactions or []) if t.action == "Interest on cash"]
        csv_stock_distributions = [t for t in (self._csv_transactions or []) 
                                   if t.action in ("Stock distribution", "Custom stock distribution")]
        csv_stock_splits = [t for t in (self._csv_transactions or []) 
                           if t.action in ("Stock split open", "Stock split close")]
        csv_adjustments = [t for t in (self._csv_transactions or []) if t.action == "Result adjustment"]
        csv_adr_fees = [t for t in (self._csv_transactions or []) if t.action == "ADR Fee"]
        
        report["summary"] = {
            "data_source": "CSV",
            "total_csv_rows": len(self._csv_transactions or []),
            "action_breakdown": csv_action_counts,
            "positions": len(self._positions or []),
            "pending_orders": len(self._pending_orders or []),
        }
        
        # =====================================================================
        # Section 2: Cash Flow Calculation (CSV-first)
        # =====================================================================
        
        # Use CSV data for calculations when available
        if self._csv_transactions:
            total_deposits = sum(t.total for t in csv_deposits)
            total_withdrawals = sum(abs(t.total) for t in csv_withdrawals)
            total_dividends = sum(t.total for t in csv_dividends)
            total_lending = sum(t.total for t in csv_lending_interest)
            total_cash_interest = sum(t.total for t in csv_cash_interest)
            total_adjustments = sum(t.total for t in csv_adjustments)
            
            # Calculate buy/sell totals from CSV
            total_buy_cost = sum(abs(t.total) for t in csv_buy_orders)
            total_sell_proceeds = sum(abs(t.total) for t in csv_sell_orders)
            
            # ADR fees are separate entries that reduce cash balance
            # Other fees are already embedded in transaction totals
            total_fees = sum(abs(t.total) for t in csv_adr_fees)
        else:
            # No CSV data available - this is now an error condition
            print("[Trading212] Warning: No CSV exports found - unable to calculate cash flow", flush=True)
            total_deposits = D(0)
            total_withdrawals = D(0)
            total_fees = D(0)
            total_dividends = D(0)
            total_lending = D(0)
            total_cash_interest = D(0)
            total_adjustments = D(0)
            total_buy_cost = D(0)
            total_sell_proceeds = D(0)
        
        # Expected cash balance calculation
        expected_cash = (
            total_deposits 
            - total_withdrawals 
            - total_fees 
            + total_dividends 
            + total_lending 
            + total_cash_interest
            + total_adjustments
            - total_buy_cost 
            + total_sell_proceeds
        )
        
        # Get actual cash from API
        actual_cash = D(0)
        if self._account_summary:
            actual_cash = (
                self._account_summary.cash_available 
                + self._account_summary.cash_in_pies 
                + self._account_summary.cash_reserved
            )
        
        cash_difference = actual_cash - expected_cash
        
        report["cash_flow"] = {
            "data_source": "CSV" if self._csv_transactions else "JSON",
            "deposits": str(total_deposits),
            "withdrawals": str(total_withdrawals),
            "fees": str(total_fees),
            "dividends": str(total_dividends),
            "lending_interest": str(total_lending),
            "cash_interest": str(total_cash_interest),
            "adjustments": str(total_adjustments) if self._csv_transactions else "N/A",
            "buy_cost": str(total_buy_cost),
            "sell_proceeds": str(total_sell_proceeds),
            "expected_cash": str(expected_cash),
            "actual_cash": str(actual_cash),
            "difference": str(cash_difference),
            "currency": self._account_summary.currency if self._account_summary else "EUR",
        }
        
        # Add discrepancy if significant
        if abs(cash_difference) > D("0.01"):
            report["discrepancies"].append({
                "type": "cash_balance",
                "expected": str(expected_cash),
                "actual": str(actual_cash),
                "difference": str(cash_difference),
                "note": "Difference may be due to FX rates, timing, or missing transactions",
            })
        
        # =====================================================================
        # Section 3: Position Reconciliation (CSV-first)
        # =====================================================================
        # Calculate expected positions using ISIN as common key
        # CSV uses short tickers (AAPL), API uses Trading212 format (AAPL_US_EQ)
        # ISIN is consistent across both sources
        expected_positions: Dict[str, Decimal] = {}  # Key: ISIN
        isin_to_symbol: Dict[str, str] = {}  # Map ISIN to beancount symbol
        
        # Build a map of corporate actions by ISIN for quick lookup
        ca_by_isin: Dict[str, List[CorporateAction]] = {}
        if self._corporate_actions:
            for ca in self._corporate_actions:
                if ca.isin not in ca_by_isin:
                    ca_by_isin[ca.isin] = []
                ca_by_isin[ca.isin].append(ca)
        
        def apply_splits_to_shares(isin: str, shares: Decimal, txn_date: datetime.date) -> Decimal:
            """Apply all applicable splits to shares based on transaction date.
            
            If transaction is before split date, multiply shares by split ratio.
            If transaction is after split date, keep shares as-is.
            """
            if isin not in ca_by_isin:
                return shares
            
            adjusted_shares = shares
            for ca in ca_by_isin[isin]:
                # Only apply split if transaction is BEFORE the split date
                if txn_date < ca.date:
                    if ca.action_type == "reverse_split":
                        # Reverse split: divide by ratio (e.g., 30:1 means divide by 30)
                        adjusted_shares = adjusted_shares * D(ca.ratio_to) / D(ca.ratio_from)
                    elif ca.action_type == "split":
                        # Forward split: multiply by ratio (e.g., 10:1 means multiply by 10)
                        adjusted_shares = adjusted_shares * D(ca.ratio_from) / D(ca.ratio_to)
            
            return adjusted_shares
        
        
        if self._csv_transactions:
            # Use CSV data - key by ISIN, apply date-aware splits
            # Sort by date to ensure buys are processed before sells for position tracking
            for t in sorted(csv_orders, key=lambda x: x.time):
                isin = t.isin
                if not isin:
                    continue
                if isin not in expected_positions:
                    expected_positions[isin] = D(0)
                    isin_to_symbol[isin] = self._get_beancount_symbol(t.ticker, isin)
                
                qty = t.num_shares or D(0)
                # Apply splits based on transaction date
                adjusted_qty = apply_splits_to_shares(isin, qty, t.time.date())
                
                # Corporate action sells (price ~ $0, total ~ $0) can be two types:
                # 1. Delisting: shares were purchased, now worthless - SHOULD subtract
                # 2. Conversion: shares came from corporate action, no buys - should skip
                # We detect conversion by checking if subtracting would make position negative
                is_zero_price_sell = (
                    "sell" in t.action.lower() and
                    t.price_per_share is not None and
                    abs(t.price_per_share) < D("0.0001") and
                    abs(t.total) < D("0.01")
                )
                
                # Only skip if this would result in negative position (conversion case)
                current_position = expected_positions.get(isin, D(0))
                is_conversion_sell = is_zero_price_sell and (current_position - adjusted_qty < 0)
                
                if "buy" in t.action.lower():
                    expected_positions[isin] += adjusted_qty
                elif "sell" in t.action.lower() and not is_conversion_sell:
                    expected_positions[isin] -= adjusted_qty
                # Conversion sells are skipped - shares came from corporate action, not purchases
            
            # Account for stock distributions and splits from CSV
            for t in csv_stock_distributions:
                isin = t.isin
                if isin and t.num_shares:
                    adjusted_qty = apply_splits_to_shares(isin, t.num_shares, t.time.date())
                    expected_positions[isin] = expected_positions.get(isin, D(0)) + adjusted_qty
                    if isin not in isin_to_symbol:
                        isin_to_symbol[isin] = self._get_beancount_symbol(t.ticker, isin)
            
            for t in csv_stock_splits:
                isin = t.isin
                if isin and t.num_shares:
                    if isin not in isin_to_symbol:
                        isin_to_symbol[isin] = self._get_beancount_symbol(t.ticker, isin)
                    adjusted_qty = apply_splits_to_shares(isin, t.num_shares, t.time.date())
                    if "open" in t.action.lower():
                        expected_positions[isin] = expected_positions.get(isin, D(0)) + adjusted_qty
                    else:  # close
                        expected_positions[isin] = expected_positions.get(isin, D(0)) - adjusted_qty
        else:
            # No CSV data - cannot calculate expected positions
            print("[Trading212] Warning: No CSV exports found - unable to calculate expected positions", flush=True)
        
        # Log which corporate actions were applied (the actual application is done per-transaction above)
        applied_actions = []
        if self._corporate_actions:
            for ca in self._corporate_actions:
                isin = ca.isin
                if isin in expected_positions:
                    applied_actions.append({
                        "isin": isin,
                        "ticker": ca.ticker,
                        "type": ca.action_type,
                        "date": str(ca.date),
                        "ratio": f"{ca.ratio_from}:{ca.ratio_to}",
                        "note": ca.note or "",
                    })
                    # Ensure symbol mapping exists
                    if isin not in isin_to_symbol:
                        isin_to_symbol[isin] = self._get_beancount_symbol(ca.ticker, isin)
        
        # Store applied actions in report
        report["corporate_actions_applied"] = applied_actions
        
        # Compare with actual positions from API (keyed by ISIN)
        actual_positions: Dict[str, Decimal] = {}
        for p in (self._positions or []):
            isin = p.isin
            if isin:
                actual_positions[isin] = p.quantity
                if isin not in isin_to_symbol:
                    isin_to_symbol[isin] = self._get_beancount_symbol(p.ticker, isin)
        
        all_isins = set(expected_positions.keys()) | set(actual_positions.keys())
        
        def format_quantity(qty: Decimal) -> str:
            """Format quantity, showing 0 instead of 0E-10."""
            if qty == 0:
                return "0"
            return str(qty)
        
        position_details = []
        for isin in sorted(all_isins):
            expected_qty = expected_positions.get(isin, D(0))
            actual_qty = actual_positions.get(isin, D(0))
            diff = actual_qty - expected_qty
            
            symbol = isin_to_symbol.get(isin, isin)
            
            position_info = {
                "isin": isin,
                "symbol": symbol,
                "expected": format_quantity(expected_qty),
                "actual": format_quantity(actual_qty),
                "difference": format_quantity(diff),
            }
            position_details.append(position_info)
            
            # Flag significant differences (more than 0.0001 for fractional shares)
            if abs(diff) > D("0.0001"):
                report["discrepancies"].append({
                    "type": "position",
                    "isin": isin,
                    "symbol": symbol,
                    "expected": format_quantity(expected_qty),
                    "actual": format_quantity(actual_qty),
                    "difference": format_quantity(diff),
                })
        
        report["positions"] = {
            "data_source": "CSV",
            "count": len(all_isins),
            "details": position_details,
        }
        
        # =====================================================================
        # Section 4: Warnings
        # =====================================================================
        
        # Positions only in API (not from orders) - could indicate transfers
        api_only_positions = [isin for isin in all_isins if isin not in expected_positions and actual_positions.get(isin, D(0)) > 0]
        if api_only_positions:
            report["warnings"].append({
                "type": "positions_without_orders",
                "isins": api_only_positions,
                "symbols": [isin_to_symbol.get(isin, isin) for isin in api_only_positions],
                "note": "These positions exist in API but have no matching orders - may be transfers",
            })
        
        # Negative expected positions
        negative_positions = [(isin, q) for isin, q in expected_positions.items() if q < 0]
        if negative_positions:
            report["warnings"].append({
                "type": "negative_expected_positions",
                "positions": [{
                    "isin": isin,
                    "symbol": isin_to_symbol.get(isin, isin),
                    "quantity": str(q),
                } for isin, q in negative_positions],
                "note": "Sold more than bought - check for missing buy orders",
            })
        
        # =====================================================================
        # Section 5: Account Summary from API
        # =====================================================================
        if self._account_summary:
            report["account_summary"] = {
                "account_id": self._account_summary.account_id,
                "currency": self._account_summary.currency,
                "cash_available": str(self._account_summary.cash_available),
                "cash_in_pies": str(self._account_summary.cash_in_pies),
                "cash_reserved": str(self._account_summary.cash_reserved),
                "investments_value": str(self._account_summary.investments_value),
                "total_value": str(self._account_summary.total_value),
            }
        
        # Save report
        report_path = os.path.join(self.data_directory, "control_report.json")
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, default=str)
        
        # Print summary
        print(f"[Trading212] Control report saved to: {report_path}", flush=True)
        print(f"  Data source: CSV", flush=True)
        print(f"  CSV transactions: {report['summary']['total_csv_rows']}", flush=True)
        
        # Calculate order counts from action_breakdown
        action_counts = report['summary']['action_breakdown']
        buy_orders = sum(v for k, v in action_counts.items() if 'buy' in k.lower())
        sell_orders = sum(v for k, v in action_counts.items() if 'sell' in k.lower())
        dividends = sum(v for k, v in action_counts.items() if 'dividend' in k.lower())
        
        print(f"  Orders: Buy: {buy_orders}, Sell: {sell_orders}", flush=True)
        print(f"  Dividends: {dividends}", flush=True)
        print(f"  Positions: {report['summary']['positions']}", flush=True)
        print(f"  Cash - Expected: {expected_cash:.2f}, Actual: {actual_cash:.2f}, Diff: {cash_difference:.2f}", flush=True)
        
        if report["discrepancies"]:
            print(f"  ⚠️  {len(report['discrepancies'])} discrepancies found - check report for details", flush=True)
        if report["warnings"]:
            print(f"  ⚠️  {len(report['warnings'])} warnings - check report for details", flush=True)

    def _collect_commodities(self) -> Dict[str, CommodityInfo]:
        """Collect all unique commodities from CSV transactions and positions.
        
        Returns:
            Dict mapping symbol to CommodityInfo
        """
        commodities: Dict[str, CommodityInfo] = {}
        
        # From CSV transactions (primary source)
        if self._csv_transactions:
            for txn in self._csv_transactions:
                if not txn.ticker or not txn.isin:
                    continue
                symbol = self._get_beancount_symbol(txn.ticker, txn.isin)
                if symbol not in commodities:
                    asset_class = self._guess_asset_class(txn.ticker, txn.name)
                    exchange_name, exchange_code, yahoo_suffix = _get_exchange_from_ticker(txn.ticker, txn.isin)
                    # Get API ticker from instruments.json if available
                    api_ticker = ""
                    if self._instruments:
                        for instr_ticker, instr in self._instruments.items():
                            if instr.get("isin") == txn.isin:
                                api_ticker = instr_ticker
                                break
                    commodities[symbol] = CommodityInfo(
                        symbol=symbol,
                        name=txn.name or symbol,
                        isin=txn.isin,
                        ticker=txn.ticker,  # Primary ticker for Yahoo Finance
                        csv_ticker=txn.ticker,  # Ticker from CSV
                        api_ticker=api_ticker,  # Ticker from instruments.json
                        currency=txn.currency or "USD",
                        exchange_name=exchange_name,
                        exchange_code=exchange_code,
                        yahoo_suffix=yahoo_suffix,
                        asset_class=asset_class,
                    )
        
        # From positions (supplements CSV with current holdings)
        if self._positions:
            for position in self._positions:
                symbol = self._get_beancount_symbol(position.ticker, position.isin)
                if symbol not in commodities:
                    asset_class = self._guess_asset_class(position.ticker, position.name)
                    exchange_name, exchange_code, yahoo_suffix = _get_exchange_from_ticker(position.ticker, position.isin)
                    # Position ticker is API format - look for CSV ticker in transactions
                    csv_ticker = ""
                    if self._csv_transactions:
                        for txn in self._csv_transactions:
                            if txn.isin == position.isin:
                                csv_ticker = txn.ticker
                                break
                    commodities[symbol] = CommodityInfo(
                        symbol=symbol,
                        name=position.name or symbol,
                        isin=position.isin,
                        ticker=csv_ticker or position.ticker,  # Prefer CSV ticker for Yahoo
                        csv_ticker=csv_ticker,  # From CSV if found
                        api_ticker=position.ticker,  # Position ticker is API format
                        currency=position.currency,
                        exchange_name=exchange_name,
                        exchange_code=exchange_code,
                        yahoo_suffix=yahoo_suffix,
                        asset_class=asset_class,
                    )
        
        # From instruments.json - add any instruments not already captured
        # This provides metadata for instruments that may have been held historically
        if self._instruments:
            for ticker, instr in self._instruments.items():
                isin = instr.get("isin", "")
                symbol = self._get_beancount_symbol(ticker, isin)
                if symbol not in commodities:
                    name = instr.get("name", symbol)
                    currency = instr.get("currency", "USD")
                    asset_class = self._guess_asset_class(ticker, name)
                    exchange_name, exchange_code, yahoo_suffix = _get_exchange_from_ticker(ticker, isin)
                    # Look for CSV ticker in transactions
                    csv_ticker = ""
                    if self._csv_transactions:
                        for txn in self._csv_transactions:
                            if txn.isin == isin:
                                csv_ticker = txn.ticker
                                break
                    commodities[symbol] = CommodityInfo(
                        symbol=symbol,
                        name=name,
                        isin=isin,
                        ticker=csv_ticker or ticker,  # Prefer CSV ticker for Yahoo
                        csv_ticker=csv_ticker,  # From CSV if found
                        api_ticker=ticker,  # Instruments.json ticker is API format
                        currency=currency,
                        exchange_name=exchange_name,
                        exchange_code=exchange_code,
                        yahoo_suffix=yahoo_suffix,
                        asset_class=asset_class,
                    )
        
        return commodities

    def _guess_asset_class(self, ticker: str, name: Optional[str]) -> str:
        """Guess the asset class based on ticker and name.
        
        Returns:
            "etf", "stock", or "other"
        """
        name_lower = (name or "").lower()
        
        # Check for common ETF indicators
        etf_keywords = ["etf", "ishares", "vanguard", "wisdomtree", "vaneck", "spdr", "invesco", "(acc)", "(dist)"]
        if any(kw in name_lower for kw in etf_keywords):
            return "etf"
        
        # Check ticker suffix patterns - European ETFs often end with 'l' (London)
        if _get_exchange_suffix(ticker):
            return "etf"  # Non-US instruments are often ETFs
        
        return "stock"

    def _add_commodity_entries(self, journal: JournalEditor, results: SourceResults) -> None:
        """Add Commodity directives as pending entries for commodities not yet in journal.
        
        This allows users to confirm each commodity declaration through the beancount-import UI.
        """
        # Get all commodities we know about
        commodities_info = self._collect_commodities()
        if not commodities_info:
            return
        
        # Get commodities already declared in the journal
        existing_commodities = set(journal.commodities.keys())
        
        # Filter to only new commodities
        new_commodities = {k: v for k, v in commodities_info.items() if k not in existing_commodities}
        
        if not new_commodities:
            return
        
        print(f"[Trading212] Adding {len(new_commodities)} new commodity directives as pending entries", flush=True)
        
        # Use a fixed date for commodity declarations
        commodity_date = datetime.date(1970, 1, 1)
        
        for symbol, info in sorted(new_commodities.items()):
            # Build Yahoo Finance price source
            base_symbol = _ticker_to_base_symbol(info.ticker)
            yahoo_symbol = f"{base_symbol}{info.yahoo_suffix}"
            
            # Build metadata (all values must be strings for beancount)
            meta = {
                "name": info.name,
                "isin": info.isin,
                "price": f"{info.currency}:yahoo/{yahoo_symbol}",
                "asset_class": info.asset_class,
            }
            
            # Add ticker fields
            if info.csv_ticker:
                meta["ticker_csv"] = info.csv_ticker
            if info.api_ticker:
                meta["ticker_api"] = info.api_ticker
            
            # Add exchange info if available
            if info.exchange_code:
                meta["exchange"] = info.exchange_code
            if info.exchange_name:
                meta["exchange_name"] = info.exchange_name
            
            # Add asset allocation
            if info.asset_class == "stock":
                meta["asset_allocation_stock"] = "100"
            elif info.asset_class == "etf":
                meta["asset_allocation_etf"] = "100"
            
            # Create Commodity directive
            commodity_entry = Commodity(
                meta=meta,
                date=commodity_date,
                currency=symbol,
            )
            
            # Add as pending entry
            results.add_pending_entry(ImportResult(
                date=commodity_date,
                entries=[commodity_entry],
                info={
                    "type": "trading212_commodity",
                    "symbol": symbol,
                    "isin": info.isin,
                },
            ))

    def _generate_commodities_file(self) -> None:
        """Generate commodities.beancount file with all instrument declarations."""
        if not self.commodity_output:
            return
        
        commodities = self._collect_commodities()
        if not commodities:
            return
        
        print(f"\n[Trading212] Generating commodities file: {self.commodity_output}", flush=True)
        print(f"[Trading212] Found {len(commodities)} unique commodities", flush=True)
        
        lines = [
            "; Commodities generated by beancount-import Trading 212 source",
            f"; Generated: {datetime.datetime.now().isoformat()}",
            "",
        ]
        
        # Sort commodities by symbol
        for symbol in sorted(commodities.keys()):
            info = commodities[symbol]
            
            # Build Yahoo Finance price source
            base_symbol = _ticker_to_base_symbol(info.ticker)
            yahoo_symbol = f"{base_symbol}{info.yahoo_suffix}"
            
            lines.append(f"1970-01-01 commodity {symbol}")
            lines.append(f'  name: "{info.name}"')
            lines.append(f'  isin: "{info.isin}"')
            lines.append(f'  trading212_ticker: "{info.ticker}"')
            
            # Only include exchange fields if we have definite information
            if info.exchange_code:
                lines.append(f'  exchange: "{info.exchange_code}"')
            if info.exchange_name:
                lines.append(f'  exchange_name: "{info.exchange_name}"')
            
            lines.append(f'  price: "{info.currency}:yahoo/{yahoo_symbol}"')
            lines.append(f'  asset_class: "{info.asset_class}"')
            
            # Add asset allocation based on asset class
            if info.asset_class == "stock":
                lines.append('  asset_allocation_stock: 100')
            elif info.asset_class == "etf":
                lines.append('  asset_allocation_etf: 100')
            
            lines.append("")
        
        # Write to file
        with open(self.commodity_output, 'w', encoding='utf-8') as f:
            f.write("\n".join(lines))
        
        print(f"[Trading212] Wrote {len(commodities)} commodities to {self.commodity_output}", flush=True)
